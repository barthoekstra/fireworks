# (PART) Sovon counts {-}

# Annotating count areas

We have data for the following counts provided by Sovon:

1. Waterbird counts with a shapefile containing the surveyed areas and an `xlsx` file with the count results. Both can be linked using the `GEBIEDID` contained in both datasets.
2. PTT counts, or point transect counts, contained within an `xlsx` file with the routes and all bird observations at an $(X, Y)$ location.

To make processing efficient, we will 'annotate' the PPIs with the corresponding area codes for the waterbird counts and some identifier for the PTT counts. Doing so, we can later on calculate relevant count-based parameters (e.g. numbers of birds, average mass, etc.) and 'join' these by the corresponding identifiers.

## Setting up the annotation environment

```{r setup-process-sovon-counts, warning=FALSE, message=FALSE}
library(bioRad)
library(sf)
library(stars)
library(raster)
library(dplyr)
library(tidyr)
library(readr)
library(stringr)
library(readxl)
library(ggplot2)
library(viridis)
library(fasterize)
```

```{r read_landuse_ppis}
ppi_hrw <- readRDS("data/processed/corrected_ppi_hrw_lu.RDS")
ppi_dhl <- readRDS("data/processed/corrected_ppi_dhl_lu.RDS")
```

## Annotate PPIs with waterbird area codes

We rename the veriables retained in the shapefile to English and add a numerical `wb_area_id` which we can use to link the information retained in the shapefiles with the rasterized waterbird areas. All shapefiles are transformed to the CRS of the PPIs.

```{r load_waterbird_areas, message=FALSE}
wb_areas <- st_read("data/raw/sovon/wavo_telgebieden.shp") %>%
  rename(wb_area_nr = GEBIEDNR, wb_area_ha = OPPHA, xcoor = XCOOR, ycoor = YCOOR)
wb_areas$wb_area_id <- seq(1, length(wb_areas$wb_area_nr))

wb_areas_hrw <- st_transform(wb_areas, ppi_hrw$data@proj4string)
wb_areas_dhl <- st_transform(wb_areas, ppi_dhl$data@proj4string)
```

We rasterize specifically the newly created `wb_area_id` (as this is a numerical and not categorical value like `wb_area_nr`) following the 'template' of the existing PPIs.

```{r rasterize_waterbird_areas}
tpl_hrw <- st_as_stars(st_bbox(ppi_hrw$data), dx = ppi_hrw$data@grid@cellsize[1], dy = ppi_hrw$data@grid@cellsize[2], values = NA_real_)
tpl_dhl <- st_as_stars(st_bbox(ppi_dhl$data), dx = ppi_dhl$data@grid@cellsize[1], dy = ppi_dhl$data@grid@cellsize[2], values = NA_real_)

wb_areas_rasterized_hrw <- st_rasterize(wb_areas_hrw["wb_area_id"], template = tpl_hrw)
wb_areas_rasterized_dhl <- st_rasterize(wb_areas_dhl["wb_area_id"], template = tpl_dhl)
```

Let's see how that's gone so far.

```{r show_rasterized_waterbird_areas, fig.show='hold'}
par(pty = "s", mfrow = c(1, 2))
plot(wb_areas_rasterized_hrw, main = "Herwijnen: wb_area_id")
plot(wb_areas_rasterized_dhl, main = "Den Helder: wb_area_id")
```

Visually that seems to have gone well, now let's make sure the rasterized waterbird areas share the same features as the PPI 'rasters'.

```{r verify_rasterization_of_waterbird_areas, results='hold'}
compareRaster(as(wb_areas_rasterized_hrw, "Raster"), as(ppi_hrw$data, "RasterLayer"), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE)
compareRaster(as(wb_areas_rasterized_dhl, "Raster"), as(ppi_dhl$data, "RasterLayer"), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE)
```

Twice a `TRUE`, so the rasters are identical (except for the values), so we can merge the datasets using a `join` on the `wb_area_id`.

```{r}
# Add the wb_area_id to the PPIs
ppi_hrw$data$wb_area_id <- unlist(as.data.frame(as(wb_areas_rasterized_hrw, "Raster")))
ppi_dhl$data$wb_area_id <- unlist(as.data.frame(as(wb_areas_rasterized_dhl, "Raster")))

# Join the additional contents of the shapefiles
ppi_hrw$data@data %>%
  left_join(dplyr::select(as.data.frame(wb_areas_hrw), wb_area_id, wb_area_nr, wb_area_ha), by = c("wb_area_id" = "wb_area_id")) -> ppi_hrw$data@data
ppi_hrw$data$geometry <- NULL

ppi_dhl$data@data %>%
  left_join(dplyr::select(as.data.frame(wb_areas_dhl), wb_area_id, wb_area_nr, wb_area_ha), by = c("wb_area_id" = "wb_area_id")) -> ppi_dhl$data@data
ppi_dhl$data$geometry <- NULL
```

Let's verify if that occurred as planned.

```{r plot_waterbirds_ppis, fig.show='hold'}
plot(ppi_hrw, param = "wb_area_id", zlim = c(min(ppi_hrw$data@data$wb_area_id, na.rm = TRUE), max(ppi_hrw$data@data$wb_area_id, na.rm = TRUE)))
plot(ppi_dhl, param = "wb_area_id", zlim = c(min(ppi_dhl$data@data$wb_area_id, na.rm = TRUE), max(ppi_dhl$data@data$wb_area_id, na.rm = TRUE)))
```

This looks very comparable to the plots of the rasterized scans above and `wb_area_id` shows similar areas in similar colors, so this worked fine.

## Annotate PPIs with point-transect-counts

The PTT point transect counts are organized by routes, which consist of a few points. We can follow the same approach as above with the waterbird counts, by creating coverage shapes (like the shapefile features for the waterbird areas) for each of the routes. Using the convex hull of the points within a route seems like a good starting point to convert these points to areas. However, in that case it would appear as if birds are only counted when looking 'inwards' to this shape. By buffering these convex hulls with a radius of the average distance between successive points, a more representative coverage area can be generated.

### Loading PTT points

We load the PTT data directly from the `xlsx` file provided by Sovon and rename the variables to English.

```{r load_ptt_counts}
ptt <- read_excel("data/raw/sovon/tel_dec_jan_1718.xlsx", sheet = "ptt") %>%
  rename(count_id = tellingid, route = route, count_point = telpunt, season = seizoen, year = teljaar, month = maand, day = dag, species = soort, number = aantal)
head(ptt, 10)
```

As we're not interested in all the data here, we will load a subset of the columns, specifically all unique combinations of routes and points, which will yield the corresponding `xcoor` and `ycoor` coordinates for each `count_point` within a `route`.

```{r select_relevant_ptt_variables}
ptt %>%
  dplyr::select(route, count_point, xcoor, ycoor) %>%
  group_by(route, count_point) %>%
  slice(1) -> ptt
head(ptt, 10)
```

### Calculate interpoint distances

For each of the routes within the PTT dataset, we will calculate the average distance between the subsequent points, to buffer our convex hull by this value.

```{r calculate_ptt_interpoint_distance}
ptt %>%
  group_by(route) %>%
  mutate(xcoor2 = c(xcoor[-1], 0),
         ycoor2 = c(ycoor[-1], 0)) %>%
  rowwise() %>%
  mutate(interpoint_distance = pointDistance(cbind(xcoor, ycoor), cbind(xcoor2, ycoor2), lonlat = FALSE)) %>%
  ungroup() %>%
  filter(xcoor2 != 0) %>% # Throw out last point from route where distance to next point is not relevant
  group_by(route) %>%
  summarise(avg_interpoint_distance = mean(interpoint_distance)) -> ptt_interpoint_distances
  
ptt %>%
  left_join(ptt_interpoint_distances, by = c("route" = "route")) -> ptt

head(ptt, 10)
```

We can now calculate the convex hulls of the points grouped by `route`.

```{r calculate_route_convex_hulls, fig.show='hold'}
ptt %>%
  st_as_sf(coords = c("xcoor", "ycoor"), crs = 28992) %>%
  st_transform(crs = ppi_hrw$data@proj4string) %>%
  group_by(route, avg_interpoint_distance) %>%
  summarise() %>%
  st_convex_hull() -> ptt_convex_hulls_hrw

ptt %>%
  st_as_sf(coords = c("xcoor", "ycoor"), crs = 28992) %>%  # original CRS = EPSG:28992 (RD New)
  st_transform(crs = ppi_dhl$data@proj4string) %>%
  group_by(route, avg_interpoint_distance) %>%
  summarise() %>%
  st_convex_hull() -> ptt_convex_hulls_dhl

plot(ptt_convex_hulls_hrw[1], main = "PTT Routes Herwijnen: Route")
plot(ptt_convex_hulls_hrw[2], main = "PTT Routes Herwijnen: Avg interpoint dist.")
plot(ptt_convex_hulls_dhl[1], main = "PTT Routes Den Helder: Route")
plot(ptt_convex_hulls_dhl[2], main = "PTT Routes Den Helder: Avg interpoint dist.")
```

As we have calculated the average distance between the points, we can now buffer the convex hulls by this value to attain more representative sizes of the covered areas. 

```{r buffer_convex_hulls_with_interpoint_distance, fig.show='hold'}
ptt_convex_hulls_hrw %>%
  st_buffer(dist = as.double(ptt_convex_hulls_hrw$avg_interpoint_distance)) -> ptt_convex_hulls_hrw

ptt_convex_hulls_dhl %>%
  st_buffer(dist = as.double(ptt_convex_hulls_dhl$avg_interpoint_distance)) -> ptt_convex_hulls_dhl

plot(ptt_convex_hulls_hrw[1], main = "Buffered PTT Routes Herwijnen")
plot(ptt_convex_hulls_dhl[1], main = "Buffered PTT Routes Den Helder")
```

Now that is taken care of, we can rasterize the polygons using the `fasterize` package. As there is overlap between the areas covered by the routes using the convex hulls and a raster can only contain a single value for every pixel, we need to resolve this overlap. In this case we will compare overlapping areas and pick those where the average distance between the points for that area is lowest. This biases towards counts that cover a smaller area, so probably resulting in more accurate estimates of birds around.

```{r rasterize_convex_hulls, fig.show='hold'}
ptt_hrw <- raster(ppi_hrw$data)
ptt_dhl <- raster(ppi_dhl$data)

ptt_hrw <- fasterize(ptt_convex_hulls_hrw, ptt_hrw, field = "route", by = "avg_interpoint_distance")
ptt_dhl <- fasterize(ptt_convex_hulls_dhl, ptt_dhl, field = "route", by = "avg_interpoint_distance")

ptt_hrw <- suppressWarnings(stackApply(ptt_hrw, indices = rep(1, length(ptt_hrw)), fun = min, na.rm = TRUE))
ptt_dhl <- suppressWarnings(stackApply(ptt_dhl, indices = rep(1, length(ptt_dhl)), fun = min, na.rm = TRUE))

plot(ptt_hrw, main = "Rasterized PTT routes Herwijnen")
plot(ptt_dhl, main = "Rasterized PTT routes Den Helder")
```

This approach to solving the issue of overlapping polygons introduces a possible problem here, where it will eventually result in larger numbers of birds (corresponding to a single route) being spread over a smaller area of land (after the overlap is removed from some polygons). However, I don't really see an alternative solution to this problem, except by averaging the numbers of birds over the whole area covered by the PTT counts. This would result in much less flexibility later on when calculating relevant bird parameters, so for now we leave it as is.

With the rasterization done, let's compare the resultant raster and see if it is identical to the PPIs.

```{r verify_rasterization_of_ptt_counts, results='hold'}
compareRaster(as(ptt_hrw, "Raster"), as(ppi_hrw$data, "RasterLayer"), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE)
compareRaster(as(ptt_dhl, "Raster"), as(ppi_dhl$data, "RasterLayer"), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE)
```

Two TRUEs, so that's excellent. We can now add the `ptt_route` to the PPIs.

```{r add_ptt_routes_to_ppis}
ppi_hrw$data$ptt_route <- unlist(as.data.frame(as(ptt_hrw, "Raster")))
ppi_dhl$data$ptt_route <- unlist(as.data.frame(as(ptt_dhl, "Raster")))
```

Let's verify once again if that occurred as planned.

```{r plot_ptt_ppis, fig.show='hold'}
plot(ppi_hrw, param = "ptt_route", zlim = c(min(ppi_hrw$data@data$ptt_route, na.rm = TRUE), max(ppi_hrw$data@data$ptt_route, na.rm = TRUE)))
plot(ppi_dhl, param = "ptt_route", zlim = c(min(ppi_dhl$data@data$ptt_route, na.rm = TRUE), max(ppi_dhl$data@data$ptt_route, na.rm = TRUE)))
```

