# Processing count results

For now, we are interested in calculating the following parameters for the count results:

1. The number of birds within every PPI pixel.
2. The average mass of the birds within every PPI pixel.

We can derive the total numbers of birds comparatively easily from the bird counts by Sovon, but to calculate the average mass of the birds we need to link a database of life-history traits. For the latter we first need to translate the vernacular (modern) names of bird species to the scientific ones, so we can link both.

## Setting up the processing environment

```{r setup_annotating_count_results, warning=FALSE}
library(rgbif)
library(stringr)
library(readxl)
library(dplyr)
library(tidyr)
library(readr)
library(kableExtra)
```

## Loading the Sovon count data

The count data is spread over a few sheets in an `xlsx` file, which we load here. For clarity, we rename all the columns to English and we filter out all counts (i.e. areas) where birds are not positively identified to species level. Although it would be possible to 'fill' these uncertain counts based on proportions, determining how to do that is not necessary for our purposes. Instead, we will just remove these counts altogether. Finally, subspecies identifiers for these species are removed, as we assume there is no variation between subspecies to negatively affect our results, nor does the database of life-history traits contain parameters for subspecies.

```{r preparing_wb_counts}
sovon_data <- "data/raw/sovon/tel_dec_jan_1718.xlsx"

data <- data.frame()
sheets <- excel_sheets(sovon_data)
sheets <- sheets[-c(1, 5)]  # Sheet 1 and 5 contain PTT and roost counts respectively, so we ignore these for now, as they have to be processed differently

# Explicit column types to suppress warnings thrown because of lacking euring codes for records with no birds
coltypes <- c("numeric", "text", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "numeric", "numeric", "numeric")

for (i in seq_along(sheets)) {
  data <- rbind(data, read_excel(sovon_data, sheet = sheets[i], col_types = coltypes))
}

data %>%
  drop_na() %>%  # A few rows somehow contain no birds or species 'geen vogels'
  rename(count_id = TELLING_ID, area_nr = GEBIEDSCODE, year = JAAR, month = MAAND, day = DAG, start_time = BEGINTIJD, end_time = EINDTIJD,
         "euring" = "EURING", species = SOORT, number = Aantal, xcoor = XCOOR, ycoor = YCOOR) %>%
  group_by(area_nr) %>%
  filter(!any(str_ends(species, "spec."))) %>%  # Filter out all counts with unidentified birds
  filter(!any(length(str_subset(species, " of ")) > 0)) %>%  # Filter out all counts with either/or totals
  filter(!any(str_starts(species, "hybride"))) %>%  # Filter out all counts with hybrids
  ungroup() %>%
  rowwise() %>%
  mutate(species = str_split(species, "\\(")[[1]][1] %>% str_trim()) -> wb_data  # And remove all subspecies identifications

head(wb_data, 10) %>%
  kable(format = "html", col.names = colnames(wb_data)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

Following this logic, we can process the PTT counts similarly and see which species are contained in those.

```{r preparing_ptt_counts}
read_excel(sovon_data, sheet = 1) %>%
  rename(count_id = tellingid, route = route, count_point = telpunt, season = seizoen, year = teljaar, month = maand, 
         day = dag, euring = euring, species = soort, number = aantal, xcoor = xcoor, ycoor = ycoor) %>%
  group_by(route, count_point) %>%
  filter(!any(str_ends(species, "spec."))) %>%  # Filter out all counts with unidentified birds
  filter(!any(length(str_subset(species, " of ")) > 0)) %>%  # Filter out all counts with either/or totals
  filter(!any(str_starts(species, "hybride"))) %>%  # Filter out all counts with hybrids
  ungroup() %>%
  rowwise() %>%
  mutate(species = str_split(species, "\\(")[[1]][1] %>% str_trim()) -> ptt_data  # And remove all subspecies identifications-> ptt_data

head(ptt_data, 10) %>%
  kable(format = "html", col.names = colnames(ptt_data)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

## Filtering/preprocessing species names

The following section is the result of an iterative process aimed at matching species in our count data with species in the database of life-history characteristics. Unfortunately, automatic tools only get us so far, a bit of tweaking has to be done by hand. To reduce manual corrections needed, *only species to which >1% of the birds belong in a single count* have been corrected manually. In other words: if a species which cannot be matched always accounts for less than 1% of the total number of birds within a count, this species is discarded from the whole dataset.

Besides the 1% criteria, both the waterbird and PTT counts contain some exotics (e.g. 'Helmparelhoen'/Helmeted guineafowl) for which our life-history characteristics dataset does not contain any measurements anyways (there are others that we do have measurements of), some species that are very unlikely to ever take flight during NYE (e.g. 'Kip'/Domesticated chicken) and some mammals for which the same applies. We will remove these from the dataset manually.

```{r filtering_species}
exotics <- c("Helmparelhoen", "Kaapse Casarca", "Manengans", "Ringtaling", "Buffelkopeend", "Kokardezaagbek", "Chileense Flamingo",
             "Kaapse Taling", "Bahamapijlstaart", "Muskuseend", "Zwarte Zwaan", "Knobbelgans", "Zwaangans")
unlikely_flight_candidate <- c("Kip")
mammals <- c("Damhert", "Haas", "Ree", "Bever", "Bruine Rat", "Muskusrat", "Mol", "Vos", "Kat", "Otter", "Grijze Zeehond", "Konijn",
             "Eekhoorn", "Edelhert", "Gewone Zeehond", "Wild Zwijn", "Steenmarter", "Moeflon")
input_error <- c("Steltstrandloper")
remove_species <- c(exotics, unlikely_flight_candidate, mammals, input_error)

ptt_data %>%
  filter(!species %in% remove_species) -> ptt_data

wb_data %>%
  filter(!species %in% remove_species) -> wb_data
```

With all these species removed or adjusted, we can create a species lookup table. We fetch the scientific names and corresponding GBIF species IDs from the [Checklist Dutch Species Register](https://doi.org/10.15468/rjdpzy), which is the GBIF dataset with key `4dd32523-a3a3-43b7-84df-4cda02f15cf7`. We furthermore remove all unnecessary information, such as subspecies from the scientific names as well.

```{r create_species_lut}
unique_species <- unique(c(wb_data$species, ptt_data$species))

build_species_lut <- function(specieslist, datasetKey = NULL, higherTaxonKey = NULL) {
  # As this function can possibly return many different records, we pick the scientific name and GBIF ID (nubKey) that are the most
  # common in the returned results. This should most often result in an OK result of the name lookup function.
  Mode <- function(x) {
    ux <- unique(na.omit(x))
    ux[which.max(tabulate(match(x, ux)))]
  }
  
  n <- length(specieslist)
  
  species_lut <- data.frame(lookupname = character(n), 
                            scientificname = character(n), 
                            gbif_key = numeric(n), stringsAsFactors = FALSE)
  
  for(i in seq_along(specieslist)) {
    gbif_data <- tryCatch({
      gbif <- name_lookup(specieslist[i], 
                          datasetKey = datasetKey, 
                          higherTaxonKey = higherTaxonKey, 
                          return = "data")
      
      list(paste(str_split(Mode(gbif$scientificName), pattern = " ")[[1]][1:2], collapse = " "), Mode(gbif$nubKey))
    }, error = function(e) {
      list("", NaN)
    })
    
    species_lut[i, ] <- c(specieslist[i], gbif_data[1], as.numeric(as.character(gbif_data[2])))
  }
  
  return(species_lut)
}

# The following query defines a `higherTaxonKey`, which is a way to filter for birds fairly easily. 
# Somehow this ID is not fully persistent, so in case the following returns only NaNs for gbif_keys, 
# check the Aves taxon in the Checklist Dutch Species Register
species_lut <- build_species_lut(unique_species, datasetKey = "4dd32523-a3a3-43b7-84df-4cda02f15cf7", higherTaxonKey = 162425859)
head(species_lut, 10) %>%
  kable(format = "html", col.names = colnames(species_lut)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

Finally, the lookup table also contains some scientific names which unfortunately will not match with the life-history characteristics dataset, so these too we will adjust manually.

```{r manual_species_tweaks}
# Change to similar species which is in the LHT database
species_lut[species_lut$lookupname == "Toendrarietgans", "scientificname"] <- "Anser fabalis"  # Taiga Bean Goose
species_lut[species_lut$lookupname == "Kleine Canadese Gans", "scientificname"] <- "Branta leucopsis"  # Barnacle Goose
species_lut[species_lut$lookupname == "Kleine Barmsijs", "scientificname"] <- "Acanthis flammea"  # Redpoll
species_lut[species_lut$lookupname == "Pontische Meeuw", "scientificname"] <- "Larus argentatus"  # Herring Gull
species_lut[species_lut$lookupname == "Indische Gans", "scientificname"] <- "Anser albifrons"  # Greater White-fronted Goose
species_lut[species_lut$lookupname == "Canadese Gans", "scientificname"] <- "Branta canadensis"  # Canada Goose

# Change scientific name for same species to match with the LHT database
species_lut[species_lut$lookupname == "Kleine Zwaan", "scientificname"] <- "Cygnus columbianus"  # Bewick's Swan
species_lut[species_lut$lookupname == "Kokmeeuw", "scientificname"] <- "Larus ridibundus"  # Black-headed Gull
species_lut[species_lut$lookupname == "Smient", "scientificname"] <- "Mareca penelope"  # Wigeon
species_lut[species_lut$lookupname == "Krakeend", "scientificname"] <- "Mareca strepera"  # Gadwall
species_lut[species_lut$lookupname == "Slobeend", "scientificname"] <- "Spatula clypeata"  # Northern Shoveler
species_lut[species_lut$lookupname == "Winterkoning", "scientificname"] <- "Troglodytes troglodytes"  # Wren
species_lut[species_lut$lookupname == "Grote Jager", "scientificname"] <- "Catharacta skua"  # Great Skua
species_lut[species_lut$lookupname == "Roodborsttapuit", "scientificname"] <- "Saxicola torquatus"  # Stonechat
species_lut[species_lut$lookupname == "Strandleeuwerik", "scientificname"] <- "Eremophila alpestris"  # Horned Lark
```

## Linking life-history traits to species

We use the *Life-history characteristics of European birds*-dataset [@storchova_2018] to calculate the mean mass of all birds in a PPI pixel. This dataset is stored on Dryad and we can [download](https://doi.org/10.5061/dryad.n6k3n) it there. Unfortunately the `rdryad` package is severely out-of-date with the new Dryad API, so we cannot nicely automate this download yet. Anyways, the files should be downloaded manually and added to `data/raw/life-history-characteristics/`.

We calculate the mean of the mass of both sexed and unsexed birds and assume they occur 

```{r prepare_life_history_characteristics}
read_tsv("data/raw/life-history-characteristics/Life-history characteristics of European birds.txt", 
         col_types = cols_only('Species' = col_character(), 'WeightU_MEAN' = col_double(), 'WeightM_MEAN' = col_double(), 'WeightF_MEAN' = col_double())) %>%
  rowwise %>%
  mutate(mean_weight = mean(c(WeightU_MEAN, WeightF_MEAN, WeightM_MEAN))) %>%
  dplyr::select(Species, mean_weight) %>%
  rename(species = Species) %>%
  filter(!any(str_ends(species, "ssp"))) %>%  # Filter out birds not identified to species
  drop_na() -> lhc

lhc[lhc$species == "Aquila nipalenis", "species"] <- "Aquila nipalensis"  # Small error in dataset -> notified author
head(lhc, 10) %>%
  kable(format = "html", col.names = colnames(lhc)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

Now we can try to link the names once again with what can be found in GBIF.

```{r link_life_history_characteristics_with_gbif}
unique_species_lhc <- unique(lhc$species)

lhc_species_lut <- build_species_lut(unique_species_lhc, dataset = NULL)
head(lhc_species_lut, 10) %>%
  kable(format = "html", col.names = colnames(lhc_species_lut)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

With the GBIF IDs/keys in place for both the life-history characteristics, as well as the Sovon counts, we can now link the datasets together. First the waterbirds

```{r link_sovon_counts_with_life_history_characteristics_wb_counts}
lhc %>%
  left_join(lhc_species_lut, by = c("species" = "scientificname")) %>%
  dplyr::select(species, mean_weight, gbif_key) -> lhc

wb_data %>%
  left_join(species_lut, by = c("species" = "lookupname")) %>%
  left_join(dplyr::select(lhc, mean_weight, gbif_key), by = c("gbif_key" = "gbif_key")) %>%
  left_join(dplyr::select(lhc, mean_weight, species), by = c("scientificname" = "species")) %>%
  dplyr::select(-c(mean_weight.x)) %>%
  rename(mean_weight = mean_weight.y) -> wb_data_lhc
head(wb_data_lhc, 10) %>%
  kable(format = "html", col.names = colnames(wb_data_lhc)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

And then the PTT counts

```{r link_sovon_counts_with_life_history_characteristics_ptt_counts}
ptt_data %>%
  left_join(species_lut, by = c("species" = "lookupname")) %>%
  left_join(dplyr::select(lhc, mean_weight, gbif_key), by = c("gbif_key" = "gbif_key")) %>%
  left_join(dplyr::select(lhc, mean_weight, species), by = c("scientificname" = "species")) %>%
  dplyr::select(-c(mean_weight.x)) %>%
  rename(mean_weight = mean_weight.y) -> ptt_data_lhc
head(ptt_data_lhc, 10) %>%
  kable(format = "html", col.names = colnames(ptt_data_lhc)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

Now we can verify if our 1% criteria for species matching is met. We do this by calculating the proportions of birds belonging to a certain species out of the total numbers of birds counted within a count. This should result in an empty dataframe, which will stop the code chunk below from running if that is *not* the case.

```{r verify_one_percent_criteria_wb_counts}
wb_data_lhc %>%
  as.data.frame() %>%
  group_by(count_id) %>%
  mutate(total_birds_count = sum(number)) %>%
  group_by(count_id, species) %>%
  mutate(proportion_species = sum(number) / total_birds_count) %>%
  ungroup() %>%
  arrange(count_id) %>%
  filter((is.na(mean_weight) & (proportion_species > 0.01))) -> wb_data_lhc_verify

stopifnot(nrow(wb_data_lhc_verify) == 0)
rm(wb_data_lhc_verify)
```

And once again, we can do the same for the PTT counts.

```{r verify_one_percent_criteria_ptt_counts}
ptt_data_lhc %>%
  as.data.frame() %>%
  group_by(count_id) %>%
  mutate(total_birds_count = sum(number)) %>%
  group_by(count_id, species) %>%
  mutate(proportion_species = sum(number) / total_birds_count) %>%
  ungroup() %>%
  arrange(count_id) %>%
  filter((is.na(mean_weight) & (proportion_species > 0.01))) -> ptt_data_lhc_verify

stopifnot(nrow(ptt_data_lhc_verify) == 0)
rm(ptt_data_lhc_verify)
```

With that out of the way we can *finally* remove the remaining empty rows and save the PTT and waterbird counts in their final form.

```{r remove_empty_rows}
ptt_data_lhc %>%
  drop_na() -> ptt_data

wb_data_lhc %>%
  drop_na() -> wb_data
```

And we save the data for further use.

```{r save_processed_sovon_data}
saveRDS(ptt_data, file = "data/processed/sovon/ptt.RDS")
saveRDS(wb_data, file = "data/processed/sovon/wb.RDS")
```

