[
["index.html", "Fireworks Preface Abstract How to use this document", " Fireworks Bart Hoekstra 2020-02-27 Preface Abstract How to use this document Knit it Use the following line in the console or click Build Book in RStudio. bookdown::render_book(input = &quot;index.Rmd&quot;, output_format = &quot;bookdown::gitbook&quot;, clean = TRUE) Full-reproduction mode In the spirit of reproducibility, the entire analysis, which happens to be contained in this book, can be reproduced at the push of a button (almost). To facilitate faster reproduction, some code chunks are only run when full-reproduction mode is switched on. This can be done by setting the R variable full_repro to TRUE in build_bookdown.R. "],
["01.Selecting-take-off-moments.html", "1 Selecting firework take-off moment 1.1 Setting up the processing environment 1.2 Calculate the vertical profiles 1.3 Generate time series of vertical profiles 1.4 Identifying moment of take-off", " 1 Selecting firework take-off moment For this study we select the moment of ‘en masse’ take-off of birds at the turn of the year. To make sure birds are still fairly ‘close’ to the take-off habitat, we therefore pick the moment where the increase in VIR (Vertically Integrated Reflectivity) is the highest. Based on experience, one would expect this to occur between 00:05 and 00:15 on January 1st, as people tend to light the fireworks right after they have shared New Year’s wishes with each other. 1.1 Setting up the processing environment We use vol2bird included in the bioRad package (Dokter et al. 2019) to calculate the vertical profiles of reflectivity, from which we determine the exact take off moment of birds. This implies we assume birds take to the skies everywhere simultaneously, but that seems a realistic assumption given that the lighting of fireworks is synchronised by the local time, rather than the time of sunset/sunrise. library(bioRad) library(ggplot2) library(dplyr) library(tidyr) Sys.setenv(TZ = &quot;UTC&quot;) 1.2 Calculate the vertical profiles We calculate vertical profiles for the period between December 31st, 2017 22:00 and 01:00 UTC on January 1st, 2018, which corresponds with 23:00 til 02:00 local Amsterdam time (UTC + 1). It is not necessary to generate so many vp files, but it gives a better temporal overview if we add some ‘temporal padding’ around the fireworks event. Beware: to calculate the vertical profiles, a running instance of Docker is required. This code chunk will only run in full-reproduction mode. fireworks_scans &lt;- Sys.glob(file.path(&quot;data/raw/pvol/fireworks-2017-2018&quot;, &quot;*_ODIM.h5&quot;)) cat(&quot;Files left to process: &quot;, length(fireworks_scans), &quot;\\n&quot;) i = 1 for (scan in fireworks_scans) { if (i %% 5 == 0) { cat(i, &quot;... &quot;) } vpfile_out &lt;- sub(&quot;raw/pvol/fireworks-2017-2018&quot;, &quot;processed/vp/fireworks-2017-2018&quot;, scan) try(calculate_vp(scan, vpfile = vpfile_out, verbose = FALSE, mount = dirname(fireworks_scans[1]))) i = i + 1 } 1.3 Generate time series of vertical profiles We can now generate a time series of vertical profiles and plot the bird densities to get an idea of what was going on during NYE of 2017-2018. fw_hrw_vpts &lt;- Sys.glob(file.path(&quot;data/processed/vp/fireworks-2017-2018&quot;, &quot;*NL62*&quot;)) %&gt;% read_vpfiles() %&gt;% bind_into_vpts() %&gt;% regularize_vpts(interval = &quot;auto&quot;) ## projecting on 300 seconds interval grid... fw_dhl_vpts &lt;- Sys.glob(file.path(&quot;data/processed/vp/fireworks-2017-2018&quot;, &quot;*NL61*&quot;)) %&gt;% read_vpfiles() %&gt;% bind_into_vpts() %&gt;% regularize_vpts(interval = &quot;auto&quot;) ## projecting on 300 seconds interval grid... start &lt;- as.POSIXct(&quot;2017-12-31 22:00:00&quot;) end &lt;- as.POSIXct(&quot;2018-01-01 01:00:00&quot;) indexes_hrw &lt;- which(fw_hrw_vpts$datetime &gt;= start &amp; fw_hrw_vpts$datetime &lt;= end) indexes_dhl &lt;- which(fw_dhl_vpts$datetime &gt;= start &amp; fw_dhl_vpts$datetime &lt;= end) # Should mostly be identical title_hrw &lt;- expression(&quot;Herwijnen: volume density [#/km&quot;^3 * &quot;]&quot;) title_dhl &lt;- expression(&quot;Den Helder: volume density [#/km&quot;^3 * &quot;]&quot;) plot(fw_hrw_vpts[indexes_hrw], main = title_hrw) plot(fw_dhl_vpts[indexes_dhl], main = title_dhl) Both plots for Herwijnen and Den Helder show exactly what we would expect: fairly low densities of birds aloft leading up to midnight (23:00 CET), then suddenly a strong increase of birds right after midnight. For Herwijnen this peak is much more pronounced than for Den Helder, probably due to the different surroundings of the radar. As vol2bird only takes into account rangegates within 5-35km of the radar, in the case of Den Helder this contains a lot more sea surface, from which fewer birds can be expected to take off than from land. 1.4 Identifying moment of take-off We integrate the time series of vertical profiles, so we can calculate the vir derivatives and determine in what volume scan birds really take to the skies for each radar separately. integrated_hrw &lt;- integrate_profile(fw_hrw_vpts) integrated_dhl &lt;- integrate_profile(fw_dhl_vpts) integrated_hrw$vir_deriv &lt;- c(NA, diff(integrated_hrw$vir, 1)) integrated_dhl$vir_deriv &lt;- c(NA, diff(integrated_dhl$vir, 1)) integrated_hrw$radar &lt;- &quot;Herwijnen&quot; integrated_dhl$radar &lt;- &quot;Den Helder&quot; integrated &lt;- rbind(integrated_hrw, integrated_dhl) integrated_l &lt;- integrated %&gt;% pivot_longer(-c(&quot;datetime&quot;, &quot;radar&quot;), names_to = &quot;variable&quot;, values_to = &quot;value&quot;) %&gt;% filter(variable == &quot;vir&quot; | variable == &quot;vir_deriv&quot;) %&gt;% filter(datetime &gt;= start &amp; datetime &lt;= end) max_vir_deriv &lt;- integrated_l %&gt;% group_by(variable, radar) %&gt;% filter(variable == &quot;vir_deriv&quot;) %&gt;% summarize(max_value = max(value), datetime = datetime[which.max(value)]) %&gt;% arrange(radar) # Sort so order remains the same theme_set(theme_bw()) ggplot(integrated_l, aes(x = datetime)) + geom_line(aes(y = value, colour = radar, linetype = variable)) + scale_x_datetime(breaks = &quot;10 min&quot;, date_labels = &quot;%H:%M&quot;, expand = c(0, 0)) + scale_color_manual(values = c(&quot;blue&quot;, &quot;red&quot;)) + scale_linetype_discrete(name = &quot;Line type&quot;, labels = c(&quot;VIR&quot;, expression(paste(Delta,&quot;VIR/scan&quot;)))) + labs(title = &quot;Time series of Vertically Integrated Reflectivities (VIR)&quot;, subtitle = &quot;NYE 2017-2018&quot;, x = &quot;Time (CET)&quot;, y = &quot;VIR&quot;, colour = &quot;Radar&quot;, linetype = &quot;Linetype&quot;) + theme(axis.text.x = element_text(angle = -90), panel.grid.minor = element_blank()) The plot shows \\(\\Delta VIR/{scan}\\) peaks earlier for the Den Helder radar than for Herwijnen, but both at roughly the same level of 1066 and 991 respectively. We can now identify which scans ‘contain’ the moment of take-off. The datetime values correspond with the start times of the scans and the filenames of the polar volume files. max_vir_deriv[, 2:4] radar max_value datetime Den Helder 1066.0071 2017-12-31 23:05:04 Herwijnen 991.1317 2017-12-31 23:10:04 pvol_folder &lt;- &quot;data/raw/pvol/fireworks-2017-2018/&quot; hrw_dt_str &lt;- strftime(max_vir_deriv[[2, 4]], format = &quot;%Y%m%d%H%M&quot;) dhl_dt_str &lt;- strftime(max_vir_deriv[[1, 4]], format = &quot;%Y%m%d%H%M&quot;) pvol_hrw_path &lt;- paste(pvol_folder, &quot;RAD_NL62_VOL_NA_&quot;, hrw_dt_str, &quot;_ODIM.h5&quot;, sep = &quot;&quot;) pvol_dhl_path &lt;- paste(pvol_folder, &quot;RAD_NL61_VOL_NA_&quot;, dhl_dt_str, &quot;_ODIM.h5&quot;, sep = &quot;&quot;) save(pvol_hrw_path, pvol_dhl_path, file = &quot;data/processed/pvol_selection.RData&quot;) So we will continue using the following files in this study: Herwijnen: RAD_NL62_VOL_NA_201712312310_ODIM.h5 Den Helder: RAD_NL61_VOL_NA_201712312305_ODIM.h5 References "],
["02.Radar-data-preprocessing.html", "2 Radar Data Preprocessing 2.1 Setting-up the pre-processing environment 2.2 Removing electromagnetic interference 2.3 Filter meteorology using the depolarization ratio 2.4 Remove classified precipitation from polar volumes 2.5 Filter ground clutter 2.6 Range-bias correction", " 2 Radar Data Preprocessing Weather radar data of the firework events at the turns of the years usually contain some degree of precipitation clutter. To filter out precipitation advanced algorithms such as MistNet have been developed, but as we are dealing with dual-pol data here, we can use a simpler and yet robust method using the depolarization ratio (Kilambi, Fabry, and Meunier 2018). To make sure our processed weather radar data does not contain any significant proportions of precipitation or ground clutter anymore, we process the data as follows: We remove electromagnetic interference based on a visual inspection of the scan and throw out all data of affected rays. We calculate the depolarization ratio (Kilambi, Fabry, and Meunier 2018) and separate biology from meteorology by classifying all range gates with a depolarization ratio \\(&gt;-12dB\\) as biology. We subsequently ‘despeckle’ this, to remove obvious misclassifications. We average reflectivity over a number of scans before the time of the fireworks event and throw out the range-gates with highest average reflectivities. All these steps can be undertaken directly on the polar volume data, so we can subsequently directly plug the cleaned up volume into the range-bias correction. 2.1 Setting-up the pre-processing environment As usual, we use bioRad (Dokter et al. 2019), but this time we include plotly for some interactive plotting. library(bioRad) library(plotly) library(gridExtra) library(ggpubr) library(mapview) library(viridis) 2.2 Removing electromagnetic interference We have determined in which scans birds are taking off based on the maximum increase in reflectivity in the scan for each of the involved radars. Let’s now look at these scans to see how much filtering for electromagnetic interference we need to do. The easiest way to determine which rays are subject to this interference is by plotting the scans in polar coordinates (\\((r, \\alpha)\\)), so interference stands out as horizontal lines of more or less constant, or very gradually changing reflectivities. Plotting using plotly makes it easier to identify the specific problematic rays as one can zoom in to identify the exact azimuths \\(\\alpha\\). The scans we will be using: Herwijnen: RAD_NL62_VOL_NA_201712312310_ODIM.h5 Den Helder: RAD_NL61_VOL_NA_201712312305_ODIM.h5 For illustrative purposes we will only illustrate removal of EM interference for the Herwijnen, as the procedure for Den Helder is exactly identical, but this scan contains very little of said clutter. pvol_hrw &lt;- read_pvolfile(pvol_hrw_path, param = &quot;all&quot;) pvol_dhl &lt;- read_pvolfile(pvol_dhl_path, param = &quot;all&quot;) scan &lt;- plot(pvol_hrw$scans[[1]], param = &quot;DBZH&quot;, xlim = c(0, 180000)) + theme_dark() ggplotly(scan) Right away we can see that rays at two places in the scan are subject to electromagnetic interference. This is probably most problematic in the lowest elevations of the volume scan, but nevertheless each of the length(pvol_hrw$scans) scans have be checked manually. Doing so results in the identification of the following rays that contain electromagnetic interference (ei_rays), organised in a list with the scan numbers (organised ascendingly per elevation angle) as keys. Admittedly: there is another ray that seems to contain interference in the first scan, but this is so far away from the radar (150km+) it should not affect our results as no meaningful numbers of birds can be detected at that range anyways. Similarly, there are similar patterns of interference/clutter in higher elevation scans, but these too should not affect our results. ei_rays_hrw &lt;- list(c(201, 202, 214, 215), # scan 1 c(201, 202, 214, 215), # scan 2 c(201, 202, 214, 215), # scan 3 c(202, 214, 215)) # scan 4 names(ei_rays_hrw) &lt;- c(1, 2, 3, 4) ei_rays_dhl &lt;- list(c(60, 61)) # scan 1 names(ei_rays_dhl) &lt;- c(1) We can now remove the data for the affected rays in the corresponding scans by setting the values to NA (see R/remove_rays.R). source(&quot;R/remove_rays.R&quot;) pvol_hrw &lt;- remove_rays(pvol_hrw, rays = ei_rays_hrw) pvol_dhl &lt;- remove_rays(pvol_dhl, rays = ei_rays_dhl) 2.2.1 Verify removal of rays with EM interference If removal is correct, the \\((r,\\alpha)\\) plots should not show clear horizontal structures anymore. i = 1 plot(pvol_hrw$scans[[i]], param = &quot;DBZH&quot;, xlim = c(0, 180000)) + theme_dark() + labs(title = &quot;Herwijnen: Cleaned from EM interference&quot;, subtitle = paste(&quot;Elevation:&quot;, round(pvol_hrw$scans[[i]]$attributes$where$elangle, 1))) plot(pvol_dhl$scans[[i]], param = &quot;DBZH&quot;, xlim = c(0, 180000)) + theme_dark() + labs(title = &quot;Den Helder: Cleaned from EM interference&quot;, subtitle = paste(&quot;Elevation:&quot;, round(pvol_dhl$scans[[i]]$attributes$where$elangle, 1))) Well, that seems to work nicely. The remaining bits of clutter won’t affect the results much as they cover fairly small areas and consistently appear at longer distances away from the radar, where birds are difficult to detect anyways. 2.3 Filter meteorology using the depolarization ratio Meteorology can be filtered using the depolarization ratio following Kilambi et al. (2018). We calculate the depolarization ratio for the raw pvol data after EM interference has been removed and subsequently ‘despeckle’ the results to improve the classification. Despeckling works by comparing the classification of the majority of the neighbourhood rangegates with the classification of the center rangegate, and changing the latter to reflect the majority of the neighbourhood classification if there is a difference. We define the ‘neighbourhood’ as a \\(3^{\\circ}\\) by \\(3 \\times rscale\\) area centered around a focal rangegate (3 rangegates in azimuth \\(\\times\\) 3 rangegates in range) . Selecting the rangegates while taking the sphericity of the radar scan into account (e.g. ray 360 should be directly adjacent to ray 1) is made easier with the R/window_coords.R function. The despeckling is implemented in R/despeckle_scan_logical.R. With the despeckling algorithm in place, we can: Calculate the depolarization ratio (DPR). Classify biology as rangegates where DPR &gt; -12 and store this classification as BIOLR (Biology Raw) scan parameter in the pvol object. Despeckle the classification and store the outcome in the BIOLD (Biology Despeckled) scan parameter in the pvol object. source(&quot;R/window_coords.R&quot;) source(&quot;R/despeckle_scan_logical.R&quot;) # Calculate depolarization ratio, classify and despeckle biology classifications for the entire volume calculate_dpr &lt;- function(pvol){ for (i in seq_along(pvol$scans)) { # Calculate ZDR as ZDR = DBZH - DBZV pvol$scans[[i]]$params$ZDR &lt;- pvol$scans[[i]]$params$DBZH - pvol$scans[[i]]$params$DBZV attributes(pvol$scans[[i]]$params$ZDR)$param &lt;- &quot;ZDR&quot; # Calculate depolarization ratio zdr_linear &lt;- 10 ** (pvol$scans[[i]]$params$ZDR / 10) dpr_linear &lt;- (zdr_linear + 1 - 2 * sqrt(zdr_linear) * pvol$scans[[i]]$params$RHOHV) / (zdr_linear + 1 + 2 * sqrt(zdr_linear) * pvol$scans[[i]]$params$RHOHV) pvol$scans[[i]]$params$DPR &lt;- 10 * log10(dpr_linear) attributes(pvol$scans[[i]]$params$DPR)$param &lt;- &quot;DPR&quot; # Classify based on depolarization ratio biology &lt;- (pvol$scans[[i]]$params$DPR &gt; -12) * 1 # multiply by 1 to convert TRUE/FALSE to 1/0 class(biology) &lt;- c(&quot;param&quot;, &quot;matrix&quot;) attributes(biology) &lt;- attributes(pvol$scans[[i]]$params$DPR) # copy attributes from DPR attributes(biology)$param &lt;- &quot;BIOLR&quot; pvol$scans[[i]]$params$BIOLR &lt;- biology # Despeckle biology classification pvol$scans[[i]]$params$BIOLD &lt;- pvol$scans[[i]]$params$BIOLR pvol$scans[[i]]$params$BIOLD &lt;- despeckle_scan_logical(pvol$scans[[i]]$params$BIOLD) attributes(pvol$scans[[i]]$params$BIOLD)$param &lt;- &quot;BIOLD&quot; # Classify based on correlation coefficient biology_rhohv &lt;- (pvol$scans[[i]]$params$RHOHV &lt; 0.95) * 1 class(biology_rhohv) &lt;- c(&quot;param&quot;, &quot;matrix&quot;) attributes(biology_rhohv) &lt;- attributes(pvol$scans[[i]]$params$RHOHV) attributes(biology_rhohv)$param &lt;- &quot;BIOLRRHOHV&quot; pvol$scans[[i]]$params$BIOLRRHOHV &lt;- biology_rhohv # Despeckle biology classification based on correlation coefficient pvol$scans[[i]]$params$BIOLDRHOHV &lt;- pvol$scans[[i]]$params$BIOLRRHOHV pvol$scans[[i]]$params$BIOLDRHOHV &lt;- despeckle_scan_logical(pvol$scans[[i]]$params$BIOLDRHOHV) attributes(pvol$scans[[i]]$params$BIOLDRHOHV)$param &lt;- &quot;BIOLDRHOHV&quot; } return(pvol) } pvol_hrw &lt;- suppressWarnings(calculate_dpr(pvol_hrw)) # Will throw NaN warnings if not suppressed pvol_dhl &lt;- suppressWarnings(calculate_dpr(pvol_dhl)) 2.3.1 Verify DPR-based classification Now let’s plot some PPIs to verify the accuracy of DPR-based classification and the subsequent despeckling, by plotting DBZH, VRADH, DPR, BIOLR and BIOLD. source(&quot;R/side_by_side_ppi.R&quot;) side_by_side_ppi(pvol_hrw, pvol_dhl, &quot;Herwijnen&quot;, &quot;Den Helder&quot;, params = c(&quot;DBZH&quot;, &quot;VRADH&quot;, &quot;RHOHV&quot;, &quot;BIOLRRHOHV&quot;, &quot;BIOLDRHOHV&quot;, &quot;DPR&quot;, &quot;BIOLR&quot;, &quot;BIOLD&quot;)) The plots show accurate classification of the obvious precipitation zones, except at the edges of these echoes, where BIOLD is a vast improvement over BIOLR, showing the value of despeckling. Similarly, there is a lot of ‘noise’ where birds should be, but despeckling takes care of most of that quite nicely as well. Additionally, it shows a pattern we would expect to see: at closer distances to the radar most ‘speckles’ that are not near to precipitation zones are turned into biology, and at distances further from the radar they are more often ‘flipped’ to meteorology. This method may not be perfect, but it classifies birds quite conservatively. The few misclassifications that remain should not affect the results so much, as they are few in number and do not occur at the centers of precipitation echoes, so they are not likely to turn into numerical outliers. 2.4 Remove classified precipitation from polar volumes Now that we have accurate classifications of the rangegates based on depolarization ratios, we can start to remove the precipitation from the polar volumes, to retain a scan that comprises of only birds (with a few occasional misclassifications). As there are areas where DPR and DBZH do not overlap, we also have to remove all rangegates that are not classified. source(&quot;R/remove_precipitation.R&quot;) pvol_hrw &lt;- remove_precipitation(pvol_hrw) pvol_dhl &lt;- remove_precipitation(pvol_dhl) Plotting the same PPIs as before should now show a cleaned-up/precipitation-free scan next to the classifications. side_by_side_ppi(pvol_hrw, pvol_dhl, &quot;Herwijnen&quot;, &quot;Den Helder&quot;, params = c(&quot;DBZH&quot;, &quot;VRADH&quot;)) That looks very good for both Herwijnen and Den Helder radars, but for the latter we have a lot of sea clutter that still needs to be removed, but that will come when ground clutter is filtered. 2.5 Filter ground clutter We will filter out ground clutter by calculating summary statistics of the rangegate reflectivities over: The 36 scans preceding the scans selected for the study of the fireworks event (= 3 hours worth of scans). A day of clear weather closest to the 31st of December 2017. For each we will filter ground clutter based on the mean DBZH values. Using the variance and mad of the DBZH was tested, but has a few difficulties: variance is very sensitive to the outliers caused by rangegates with NA values (detection below the ‘mds’, the minimum detectable signal) occasionally flipping over to a noisy measurement, resulting in very high variances. mad is much more robust to outliers, but to compute these values we need to set NA cells to the ‘mds’ (minimum detectable signal), which will result in mad values close to, or exactly 0 for cells that never reflected as well as true static clutter, so it’s difficult to separate those. Finally, a visual inspection showed the mean and mad of DBZH (assuming one could overcome the aforementioned problem with the latter) do not differ much, but the mean is somewhat more ‘aggressive’ in filtering, which in this case is quite good. Combining the clutter removal based on a clear day as well as the 36 preceding scans lets us account for both truly static clutter (e.g. buildings) as well as clutter that is more dynamic such as sea and wind park clutter, without also requiring us to resort to filtering of dynamic clutter using a VRADH threshold. The quality of filtering is assessed visually. 2.5.1 Dynamic clutter We select 36 (3 hours worth of scans) preceding the fireworks event and add an additional margin of 3 scans (15 minutes of scans) as that the VIR plots in the previous chapter have shown numbers of birds aloft are very low and stable up to that period. available_scans_hrw &lt;- Sys.glob(file.path(&quot;data/raw/pvol/clutter-removal-20171231&quot;, &quot;*NL62*20171231*&quot;)) available_scans_dhl &lt;- Sys.glob(file.path(&quot;data/raw/pvol/clutter-removal-20171231&quot;, &quot;*NL61*20171231*&quot;)) selected_scan_hrw &lt;- sub(&quot;fireworks-2017-2018&quot;, &quot;clutter-removal-20171231&quot;, pvol_hrw_path) selected_scan_dhl &lt;- sub(&quot;fireworks-2017-2018&quot;, &quot;clutter-removal-20171231&quot;, pvol_dhl_path) selected_scan_id_hrw &lt;- match(selected_scan_hrw, available_scans_hrw) selected_scan_id_dhl &lt;- match(selected_scan_dhl, available_scans_dhl) usable_scans_hrw &lt;- available_scans_hrw[(selected_scan_id_hrw-dynamic_time_margin-dynamic_nr_preceding_scans+1): (selected_scan_id_hrw-dynamic_time_margin)] usable_scans_dhl &lt;- available_scans_dhl[(selected_scan_id_dhl-dynamic_time_margin-dynamic_nr_preceding_scans+1): (selected_scan_id_dhl-dynamic_time_margin)] We can now loop over the files one by one and stack reflectivity data (DBZH) — after filtering out precipitation — in a multidimensional array. Note: the following code chunk will only run in full-reproduction mode as it takes quite a lot of time. Results are saved, so the next iteration this chunk can be skipped. source(&quot;R/stack_rainfree_reflectivities.R&quot;) stack_rainfree_reflectivities(usable_scans_hrw, outputfile = &quot;data/processed/clutter_dynamic_hrw.RDS&quot;) stack_rainfree_reflectivities(usable_scans_dhl, outputfile = &quot;data/processed/clutter_dynamic_dhl.RDS&quot;) With all DBZH compiled in a single multidimensional array, we can calculate mean reflectivity, which we store as DBZH_AVG in a pvol that now contains the dynamic clutter map. pvol_clutter_dynamic_hrw &lt;- readRDS(&quot;data/processed/clutter_dynamic_hrw.RDS&quot;) pvol_clutter_dynamic_dhl &lt;- readRDS(&quot;data/processed/clutter_dynamic_dhl.RDS&quot;) source(&quot;R/calculate_reflectivity_stack_mean.R&quot;) pvol_clutter_dynamic_hrw &lt;- calculate_reflectivity_stack_mean(pvol_clutter_dynamic_hrw, mds) pvol_clutter_dynamic_dhl &lt;- calculate_reflectivity_stack_mean(pvol_clutter_dynamic_dhl, mds) saveRDS(pvol_clutter_dynamic_hrw, &quot;data/processed/clutter_dynamic_hrw_avg.RDS&quot;) saveRDS(pvol_clutter_dynamic_dhl, &quot;data/processed/clutter_dynamic_dhl_avg.RDS&quot;) pvol_clutter_dynamic_hrw &lt;- readRDS(&quot;data/processed/clutter_dynamic_hrw_avg.RDS&quot;) pvol_clutter_dynamic_dhl &lt;- readRDS(&quot;data/processed/clutter_dynamic_dhl_avg.RDS&quot;) 2.5.1.1 Verify dynamic clutter map Let’s see what that looks like on a basemap, using a DBZH_AVG threshold of \\(-10dbZ\\), following (Dokter et al. 2011). scan_hrw &lt;- pvol_clutter_dynamic_hrw$scans[[1]] scan_dhl &lt;- pvol_clutter_dynamic_dhl$scans[[1]] side_by_side_ppi(pvol_clutter_dynamic_hrw, pvol_clutter_dynamic_dhl, &quot;Herwijnen dynamic clutter&quot;, &quot;Den Helder dynamic clutter&quot;, params = &quot;DBZH_AVG&quot;, range_max = 50000, scan_id = 1, basemap = TRUE, zlim = c(-11, -10)) Visually assessing this clutter map shows that it works quite well, selecting e.g. areas with wind parks, sea clutter, high buildings, industry, etc. Exactly what we hoped to achieve. 2.5.2 Static clutter Now, let’s retry exactly the same procedure, but this time selecting a day with no precipitation, which can be done using this tool by KNMI, so we can filter for truly static clutter. We select the following days: Herwijnen: December 29th, 2017 Den Helder: December 25th, 2017 Note: the following code chunk will only run in full-reproduction mode as it takes a lot of time to run. Results are saved, so the next iteration this chunk can be skipped. source(&quot;R/stack_rainfree_reflectivities.R&quot;) available_scans_hrw &lt;- Sys.glob(file.path(&quot;data/raw/pvol/clutter-removal-20171229-hrw&quot;, &quot;*NL62*20171229*&quot;)) available_scans_dhl &lt;- Sys.glob(file.path(&quot;data/raw/pvol/clutter-removal-20171225-dhl&quot;, &quot;*NL61*20171225*&quot;)) stack_rainfree_reflectivities(available_scans_hrw, outputfile = &quot;data/processed/clutter_static_hrw.RDS&quot;) stack_rainfree_reflectivities(available_scans_dhl, outputfile = &quot;data/processed/clutter_static_dhl.RDS&quot;) And we calculate mean DBZH values (DBZH_AVG). pvol_clutter_static_hrw &lt;- readRDS(&quot;data/processed/clutter_static_hrw.RDS&quot;) pvol_clutter_static_dhl &lt;- readRDS(&quot;data/processed/clutter_static_dhl.RDS&quot;) source(&quot;R/calculate_reflectivity_stack_mean.R&quot;) # Source because full_repro may be set to FALSE pvol_clutter_static_hrw &lt;- calculate_reflectivity_stack_mean(pvol_clutter_static_hrw, mds) pvol_clutter_static_dhl &lt;- calculate_reflectivity_stack_mean(pvol_clutter_static_dhl, mds) saveRDS(pvol_clutter_static_hrw, &quot;data/processed/clutter_static_hrw_avg.RDS&quot;) saveRDS(pvol_clutter_static_dhl, &quot;data/processed/clutter_static_dhl_avg.RDS&quot;) pvol_clutter_static_hrw &lt;- readRDS(&quot;data/processed/clutter_static_hrw_avg.RDS&quot;) pvol_clutter_static_dhl &lt;- readRDS(&quot;data/processed/clutter_static_dhl_avg.RDS&quot;) 2.5.2.1 Verify static clutter map Let’s see what that looks like on a basemap, using a DBZH_AVG threshold of \\(-10dbZ\\), following (Dokter et al. 2011). scan_hrw &lt;- pvol_clutter_static_hrw$scans[[1]] scan_dhl &lt;- pvol_clutter_static_dhl$scans[[1]] side_by_side_ppi(pvol_clutter_static_hrw, pvol_clutter_dynamic_dhl, &quot;Herwijnen static clutter&quot;, &quot;Den Helder static clutter&quot;, params = &quot;DBZH_AVG&quot;, range_max = 50000, scan_id = 1, basemap = TRUE, zlim = c(-11, -10)) 2.5.3 Remove dynamic and static clutter Now that we have identified both dynamic and static clutter, we can create the final cleaned up polar volume. source(&quot;R/remove_groundclutter.R&quot;) pvol_hrw &lt;- remove_groundclutter(remove_groundclutter(pvol_hrw, pvol_clutter_dynamic_hrw), pvol_clutter_static_hrw) pvol_dhl &lt;- remove_groundclutter(remove_groundclutter(pvol_dhl, pvol_clutter_dynamic_dhl), pvol_clutter_static_dhl) saveRDS(pvol_hrw, file = &quot;data/processed/pvol_clean_hrw.RDS&quot;) saveRDS(pvol_dhl, file = &quot;data/processed/pvol_clean_dhl.RDS&quot;) 2.6 Range-bias correction With all identifiable sources of clutter removed from the raw polar volume, we can apply the range-bias correction (Add Ref). For this it is necessary to calculate the local vertical profile for each of the radars. Ideally, this would be done using the filtered pvol we have now generated, but the vol2bird algorithm (Dokter et al. 2011) only takes pvol files as input, rather than R objects. As there is no implementation of a converter yet, for now a vp of the raw pvol files will have to do. As there is no precipitation within the relevant distance to the radars (5-35km), the calculated vp based on the raw pvol files should not differ wildly from that of the filtered pvol R object we have generated in the previous steps. vp_hrw &lt;- calculate_vp(file = pvol_hrw_path, vpfile = paste(&quot;data/processed/vp/&quot;, basename(pvol_hrw_path), sep = &quot;&quot;), verbose = FALSE) vp_dhl &lt;- calculate_vp(file = pvol_dhl_path, vpfile = paste(&quot;data/processed/vp/&quot;, basename(pvol_dhl_path), sep = &quot;&quot;), verbose = FALSE) corrected_ppi_hrw &lt;- integrate_to_ppi(pvol_hrw, vp_hrw, res = 500, xlim = c(-50000, 50000), ylim = c(-50000, 50000)) corrected_ppi_dhl &lt;- integrate_to_ppi(pvol_dhl, vp_dhl, res = 500, xlim = c(-50000, 50000), ylim = c(-50000, 50000)) saveRDS(corrected_ppi_hrw, file = &quot;data/processed/corrected_ppi_hrw.RDS&quot;) saveRDS(corrected_ppi_dhl, file = &quot;data/processed/corrected_ppi_dhl.RDS&quot;) We can now plot the final range-corrected PPIs. p_vir_hrw &lt;- plot(corrected_ppi_hrw, param = &quot;VIR&quot;, zlim = c(0, 20000)) + labs(title = &quot;Herwijnen: VIR&quot;) p_vir_dhl &lt;- plot(corrected_ppi_dhl, param = &quot;VIR&quot;, zlim = c(0, 20000)) + labs(title = &quot;Den Helder: VIR&quot;) ggarrange(p_vir_hrw, p_vir_dhl, ncol = 2, nrow = 1, common.legend = TRUE, legend = &quot;right&quot;) It’s a little hard to interpret with the PPI pixels that contain no birds set to 0 and no landscape below, so let’s see what it looks like on a basemap. As there are some ships out at the North Sea causing reflectivities orders of magnitude higher and thus stretching the colormap, we — for now — need to ‘clip’ these values to a maximum set at the value of the 99th percentile. source(&quot;R/clip.R&quot;) filtered_corrected_ppi_hrw &lt;- corrected_ppi_hrw filtered_corrected_ppi_hrw$data@data &lt;- as.data.frame(apply(filtered_corrected_ppi_hrw$data@data, 2, clip, bounds = c(0.05, 0.99))) filtered_corrected_ppi_dhl &lt;- corrected_ppi_dhl filtered_corrected_ppi_dhl$data@data &lt;- as.data.frame(apply(filtered_corrected_ppi_dhl$data@data, 2, clip, bounds = c(0.05, 0.99))) 2.6.1 Range-corrected PPI of Herwijnen radar mapview(filtered_corrected_ppi_hrw$data, alpha.regions = 0.6, col.regions = inferno, maxpixels=2000000, na.color = &quot;#00000000&quot;, map.types = c(&quot;CartoDB.Positron&quot;, &quot;CartoDB.DarkMatter&quot;, &quot;Esri.WorldImagery&quot;), layer.name = colnames(filtered_corrected_ppi_hrw$data@data)) 2.6.2 Range-corrected PPI of Den Helder radar mapview(filtered_corrected_ppi_dhl$data, alpha.regions = 0.6, col.regions = inferno, maxpixels=2000000, na.color = &quot;#00000000&quot;, map.types = c(&quot;CartoDB.Positron&quot;, &quot;CartoDB.DarkMatter&quot;, &quot;Esri.WorldImagery&quot;), layer.name = colnames(filtered_corrected_ppi_dhl$data@data)) References "],
["03.Annotate-land-use.html", "3 Annotating land use 3.1 Setting up the annotation environment 3.2 Converting the land use map 3.3 Adding land use classifications to the PPIs 3.4 Classify land use types in Urban vs. Rural 3.5 Calculate distance to nearest urban area 3.6 Add population density 3.7 Testing", " 3 Annotating land use In this study we aim to calculate ‘representative’ radar cross sections for birds aloft, based on the take-off habitat, which is probably a good indicator for the bird species/species groups measured by the radar. In this notebook we will classify land use and calculate the distance to the nearest urbanised areas for each of the PPI ‘pixels’. The land use is based on the CORINE Land Cover dataset and specifically the 2018 version (CLC2018), which should be most relevant for the 2017-2018 fireworks event. 3.1 Setting up the annotation environment library(raster) library(sf) library(stars) library(dplyr) library(ggplot2) library(ggpubr) library(gridExtra) library(viridis) library(mapview) 3.2 Converting the land use map To start, we need to convert the land use map to the same 1) resolution, and 2) extent of the radar PPIs as we can then simply ‘overlay’ both rasters on top of each other and do calculations. We load the PPIs and extract the CRS information contained in the proj4 strings. ppi_hrw &lt;- readRDS(&quot;data/processed/corrected_ppi_hrw.RDS&quot;) ppi_dhl &lt;- readRDS(&quot;data/processed/corrected_ppi_dhl.RDS&quot;) ppi_proj4_hrw &lt;- ppi_hrw$data@proj4string ppi_proj4_dhl &lt;- ppi_dhl$data@proj4string And we load and prepare the land use map it’s all about. To aid the classification process, we also load the land use classes contained in the entire CLC2018 dataset, otherwise the classes will remain anonymous numbers. landuse &lt;- raster(&quot;data/raw/landuse/clc2018_clc2018_v2018_20_raster100m/CLC2018_CLC2018_V2018_20.tif&quot;) landuse_classes &lt;- read.csv(&quot;data/raw/landuse/clc2018_clc2018_v2018_20_raster100m/Legend/CLC2018_CLC2018_V2018_20_QGIS.txt&quot;, col.names = c(&quot;landuse_id&quot;, &quot;r&quot;, &quot;g&quot;, &quot;b&quot;, &quot;x&quot;, &quot;landuse_class&quot;))[, c(&quot;landuse_id&quot;, &quot;landuse_class&quot;)] 3.2.1 Cropping the land use map As the CLC2018 dataset is so large it does not fit in memory at all in the steps below, so we have to crop the raster dataset for further processing. Even then, it still requires a beefy computer to process these files. First we calculate a bounding box for the landuse raster based on the bounding boxes of the radar data. padding &lt;- 25000 # Padding in m to make sure we crop out of the land use map with a wide margin to compensate for edge-effects later bbox_meters &lt;- abs(ppi_dhl$data@bbox[[1]]) + padding # Assuming the PPI range of DHL and HRW are the same bbox_hrw &lt;- st_bbox(c(xmin = -bbox_meters, ymin = -bbox_meters, xmax = bbox_meters, ymax = bbox_meters), crs = ppi_proj4_hrw) bbox_dhl &lt;- st_bbox(c(xmin = -bbox_meters, ymin = -bbox_meters, xmax = bbox_meters, ymax = bbox_meters), crs = ppi_proj4_dhl) bbox_hrw %&gt;% st_as_sfc() %&gt;% st_transform(crs(landuse)) %&gt;% st_bbox -&gt; bbox_landuse_hrw bbox_dhl %&gt;% st_as_sfc() %&gt;% st_transform(crs(landuse)) %&gt;% st_bbox -&gt; bbox_landuse_dhl We can now crop and plot the land use maps centered on the radar sites, with a 2.510^{4} meter padding surrounding the extent of the radar data. ext_hrw &lt;- extent(c(bbox_landuse_hrw[1], bbox_landuse_hrw[3], bbox_landuse_hrw[2], bbox_landuse_hrw[4])) ext_dhl &lt;- extent(c(bbox_landuse_dhl[1], bbox_landuse_dhl[3], bbox_landuse_dhl[2], bbox_landuse_dhl[4])) landuse_crop_hrw &lt;- crop(landuse, ext_hrw) landuse_crop_dhl &lt;- crop(landuse, ext_dhl) And plot the result: par(pty = &quot;s&quot;, mfrow = c(1, 2)) image(landuse_crop_hrw, main = &quot;Herwijnen&quot;) image(landuse_crop_dhl, main = &quot;Den Helder&quot;) Apparantly large swathes of the North Sea are set to NaN, so we better convert those to ‘Sea and ocean’ as well. sea_id &lt;- match(&#39;Sea and ocean&#39;, landuse_classes$landuse_class) landuse_crop_hrw[is.na(landuse_crop_hrw)] &lt;- landuse_classes[sea_id, &quot;landuse_id&quot;] landuse_crop_dhl[is.na(landuse_crop_dhl)] &lt;- landuse_classes[sea_id, &quot;landuse_id&quot;] par(pty = &quot;s&quot;, mfrow = c(1, 2)) image(landuse_crop_hrw, main = &quot;Herwijnen&quot;) image(landuse_crop_dhl, main = &quot;Den Helder&quot;) 3.2.2 Reprojecting the land use map Now that the land use map is cropped, we can start the reprojecting to the CRS of the radar PPI. As we’re dealing with categorical data, we set method = &quot;ngb&quot; to use nearest neighbour interpolation. landuse_hrw_reprojected &lt;- projectRaster(landuse_crop_hrw, crs = ppi_proj4_hrw, method = &quot;ngb&quot;) landuse_dhl_reprojected &lt;- projectRaster(landuse_crop_dhl, crs = ppi_proj4_dhl, method = &quot;ngb&quot;) levels(landuse_hrw_reprojected) &lt;- levels(landuse_crop_hrw) levels(landuse_dhl_reprojected) &lt;- levels(landuse_crop_dhl) If the reprojection went successful, the CRS of the reprojected land use map and the radar PPI should be the same. compareCRS(ppi_hrw$data@proj4string, landuse_hrw_reprojected@crs) compareCRS(ppi_dhl$data@proj4string, landuse_dhl_reprojected@crs) ## [1] TRUE ## [1] TRUE Apparently that is the case. 3.2.3 Resampling the land use map to a lower resolution The cellsize of the PPIs is 500, 500x500, 500 meters, but the land use map is much more finely detailed (~100x100m), so we need to resample the latter to derive a land use map at a 500, 500x500, 500 meter resolution as well. Simple nearest neighbour resampling was tested, but resulted in large parts of fairly small water bodies and especially the rivers ‘disappearing’ from the map, whereas these represent important habitats for birds to forage and roost. So instead, majority resampling, tweaked to retain more of the aforementioned water features was used to resize the land use raster to an appropriate resolution. The tweak constituted of setting the values of water courses and water bodies to the maximum value (total coverage of the assessed window) if half or more of the assessed window contained pixels classified as water courses or water bodies. The quality of this resampling was assessed visually. majority_resampling &lt;- function(raster, reference_raster, overwrite = FALSE) { values &lt;- c(sort(unique(getValues(raster)))) # classes: multidimensional logical array for the classes contained within the land use map classes &lt;- layerize(raster, filename = paste(&quot;data/processed/landuse/layerize/&quot;, substitute(raster), sep = &quot;&quot;), format = &quot;raster&quot;, bylayer = TRUE, classes = values, overwrite = overwrite) # factor: nr of cells in both horizontal and vertical direction to aggregate factor &lt;- round(dim(raster)[1:2] / dim(reference_raster)[1:2]) # agg: aggregated version of classes (aggregation factor defined by factor) containing max values per class, so 1 if a class is present agg &lt;- aggregate(classes, factor, na.rm = TRUE, fun = max) # x: resampled agg, now roughly containing land coverage percentages. Method must be bilinear, otherwise arbitrary choices keep being made. x &lt;- resample(agg, reference_raster) # Tweak the importance of water courses and bodies water_courses_id &lt;- match(511, values) water_bodies_id &lt;- match(512, values) x[[water_courses_id]][x[[water_courses_id]] &gt;= 0.5] &lt;- 1.1 x[[water_bodies_id]][x[[water_bodies_id]] &gt;= 0.5] &lt;- 1.1 # Flatten x in y y &lt;- which.max(x) # Reclassify back to original values values &lt;- data.frame(seq(1, length(values)), values) colnames(values) &lt;- c(&quot;is&quot;, &quot;becomes&quot;) y &lt;- reclassify(y, values) return(y) } landuse_hrw &lt;- majority_resampling(landuse_hrw_reprojected, as(ppi_hrw$data, &quot;RasterLayer&quot;), overwrite = TRUE) landuse_dhl &lt;- majority_resampling(landuse_dhl_reprojected, as(ppi_dhl$data, &quot;RasterLayer&quot;), overwrite = TRUE) writeRaster(landuse_hrw, &quot;data/processed/landuse/landuse_hrw_500m.tif&quot;, overwrite = TRUE) writeRaster(landuse_dhl, &quot;data/processed/landuse/landuse_dhl_500m.tif&quot;, overwrite = TRUE) By now the resampled land use raster should be very similar to the PPI raster, with the exception of — of course — the values contained within. compareRaster(landuse_hrw, as(ppi_hrw$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) compareRaster(landuse_dhl, as(ppi_dhl$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) ## [1] TRUE ## [1] TRUE Ok, let’s save a copy of what we have so far. saveRDS(landuse_hrw, &quot;data/processed/landuse/landuse_hrw.RDS&quot;) saveRDS(landuse_dhl, &quot;data/processed/landuse/landuse_dhl.RDS&quot;) 3.3 Adding land use classifications to the PPIs With the land use rasters overlapping exactly with the PPIs, we can simply extract the values of the resampled land use rasters and add these as additional parameters to the PPIs. Besides the code used, we will also add a description of the codes. landuse_hrw &lt;- readRDS(&quot;data/processed/landuse/landuse_hrw.RDS&quot;) landuse_dhl &lt;- readRDS(&quot;data/processed/landuse/landuse_dhl.RDS&quot;) values_hrw &lt;- as.data.frame(landuse_hrw@data@values) values_dhl &lt;- as.data.frame(landuse_dhl@data@values) ppi_hrw$data$landuse &lt;- as.numeric(unlist(values_hrw)) ppi_dhl$data$landuse &lt;- as.numeric(unlist(values_dhl)) ppi_hrw$data@data &lt;- ppi_hrw$data@data %&gt;% left_join(landuse_classes, by = c(&quot;landuse&quot; = &quot;landuse_id&quot;)) ppi_hrw$data$ID &lt;- NULL ppi_dhl$data@data &lt;- ppi_dhl$data@data %&gt;% left_join(landuse_classes, by = c(&quot;landuse&quot; = &quot;landuse_id&quot;)) ppi_dhl$data$ID &lt;- NULL 3.4 Classify land use types in Urban vs. Rural As we are interested in the effect urbanization has on the take-off decision of birds during the fireworks event, it is useful to categorise the land use types we have found so far as either ‘urban’ or ‘rural’ as well. urban_hrw &lt;- ppi_hrw$data@data$landuse &lt; 200 ppi_hrw$data$type &lt;- rep(&quot;rural&quot;, nrow(ppi_hrw$data)) ppi_hrw$data$type[urban_hrw] &lt;- &quot;urban&quot; ppi_hrw$data$type &lt;- as.factor(ppi_hrw$data$type) urban_dhl &lt;- ppi_dhl$data@data$landuse &lt; 200 ppi_dhl$data$type &lt;- rep(&quot;rural&quot;, nrow(ppi_dhl$data)) ppi_dhl$data$type[urban_dhl] &lt;- &quot;urban&quot; ppi_dhl$data$type &lt;- as.factor(ppi_dhl$data$type) 3.5 Calculate distance to nearest urban area For every cell on the raster that is not a cell we have just classified as ‘urban’ we will calculate the distance (in meters) to the nearest cell classified as ‘urban’. urban_hrw &lt;- ppi_hrw$data[, , &quot;type&quot;, drop = FALSE] urban_hrw$type[urban_hrw$type == &quot;rural&quot;] &lt;- NaN distance_to_urban_hrw &lt;- distance(as(urban_hrw, &#39;RasterLayer&#39;)) urban_dhl &lt;- ppi_dhl$data[, , &quot;type&quot;, drop = FALSE] urban_dhl$type[urban_dhl$type == &quot;rural&quot;] &lt;- NaN distance_to_urban_dhl &lt;- distance(as(urban_dhl, &#39;RasterLayer&#39;)) writeRaster(distance_to_urban_hrw, &quot;data/processed/landuse/dist_urban_hrw_500m.tif&quot;, overwrite = TRUE) writeRaster(distance_to_urban_dhl, &quot;data/processed/landuse/dist_urban_dhl_500m.tif&quot;, overwrite = TRUE) And we add these values to the PPIs again. values_dist_urban_hrw &lt;- as.data.frame(distance_to_urban_hrw@data@values) values_dist_urban_dhl &lt;- as.data.frame(distance_to_urban_dhl@data@values) ppi_hrw$data$dist_urban &lt;- as.numeric(unlist(values_dist_urban_hrw)) ppi_dhl$data$dist_urban &lt;- as.numeric(unlist(values_dist_urban_dhl)) 3.6 Add population density cbs_maps &lt;- st_read(&quot;data/raw/population-density/2019-CBS_VK500_2018_v1/CBS_VK500_2018_v1.shp&quot;) ## Reading layer `CBS_VK500_2018_v1&#39; from data source `/mnt/volume_ams3_01/raw/population-density/2019-CBS_VK500_2018_v1/CBS_VK500_2018_v1.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 151108 features and 31 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 13000 ymin: 306500 xmax: 278500 ymax: 619500 ## epsg (SRID): NA ## proj4string: +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs cbs_hrw &lt;- st_transform(cbs_maps, ppi_hrw$data@proj4string) cbs_dhl &lt;- st_transform(cbs_maps, ppi_dhl$data@proj4string) # Rasterize pop_density_rasterized_hrw &lt;- st_rasterize(cbs_hrw[&quot;INWONER&quot;], template = st_as_stars(st_bbox(ppi_hrw$data), dx = ppi_hrw$data@grid@cellsize[1], dy = ppi_hrw$data@grid@cellsize[2], values = NA_real_)) pop_density_rasterized_dhl &lt;- st_rasterize(cbs_dhl[&quot;INWONER&quot;], template = st_as_stars(st_bbox(ppi_dhl$data), dx = ppi_dhl$data@grid@cellsize[1], dy = ppi_dhl$data@grid@cellsize[2], values = NA_real_)) compareRaster(as(pop_density_rasterized_hrw, &quot;Raster&quot;), as(ppi_hrw$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) compareRaster(as(pop_density_rasterized_dhl, &quot;Raster&quot;), as(ppi_dhl$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) ## [1] TRUE ## [1] TRUE We can now calculate the total population in an area within ~2.5km around the center point. weights &lt;- matrix(1, nrow = 11, ncol = 11) pop_density_rasterized_hrw[pop_density_rasterized_hrw &lt; 0] &lt;- 0 pop_density_rasterized_dhl[pop_density_rasterized_dhl &lt; 0] &lt;- 0 pop_hrw &lt;- focal(as(pop_density_rasterized_hrw, &quot;Raster&quot;), w = weights, fun = sum, pad = TRUE, padValue = 0) pop_dhl &lt;- focal(as(pop_density_rasterized_dhl, &quot;Raster&quot;), w = weights, fun = sum, pad = TRUE, padValue = 0) And add it to the PPIs. values_pop_hrw &lt;- as.data.frame(pop_hrw@data@values) values_pop_dhl &lt;- as.data.frame(pop_dhl@data@values) ppi_hrw$data$pop &lt;- as.numeric(unlist(values_pop_hrw)) ppi_dhl$data$pop &lt;- as.numeric(unlist(values_pop_dhl)) 3.7 Testing Let’s make a few plots to see if what we have now gathered as additional information makes any sense 3.7.1 Plotting total VIR per land use type data_hrw &lt;- ppi_hrw$data@data %&gt;% filter(landuse_class != &quot;Land principally occupied by agriculture with significant areas of natural vegetation&quot; &amp; landuse_class != &quot;Sea and ocean&quot;) %&gt;% group_by(landuse_class) %&gt;% add_count() %&gt;% mutate(total_landuse_class = sum(VIR), total_prop_landuse_class = sum(VIR) / n) data_dhl &lt;- ppi_dhl$data@data %&gt;% filter(landuse_class != &quot;Land principally occupied by agriculture with significant areas of natural vegetation&quot; &amp; landuse_class != &quot;Sea and ocean&quot;) %&gt;% group_by(landuse_class) %&gt;% add_count() %&gt;% mutate(total_landuse_class = sum(VIR), total_prop_landuse_class = sum(VIR) / n) ggplot(data_hrw, aes(landuse_class, total_prop_landuse_class, fill = type)) + geom_col() + coord_flip() + labs(title = &quot;Herwijnen&quot;) ggplot(data_dhl, aes(landuse_class, total_prop_landuse_class, fill = type)) + geom_col() + coord_flip() + labs(title = &quot;Den Helder&quot;) 3.7.2 Plotting a distance to urban areas effect for VIR ggplot(ppi_dhl$data@data, aes(x = dist_urban, y = VIR, colour = landuse_class)) + geom_point(alpha = 0.5) + ylim(c(0, 500000)) + theme(legend.position = &quot;none&quot;) ggplot(ppi_hrw$data@data, aes(x = dist_urban, y = VIR, colour = landuse_class)) + geom_point(alpha = 0.5) + ylim(c(0, 500000)) + theme(legend.position = &quot;none&quot;) That seems alright, so we can save the PPIS we have now annotated. saveRDS(ppi_hrw, file = &quot;data/processed/corrected_ppi_hrw_lu.RDS&quot;) saveRDS(ppi_dhl, file = &quot;data/processed/corrected_ppi_dhl_lu.RDS&quot;) 3.7.3 Plotting it all on an interactive map 3.7.3.1 Interactive map of Herwijnen mapview(ppi_hrw$data[, , c(&quot;pop&quot;, &quot;dist_urban&quot;)], alpha.regions = 0.6, col.regions = inferno, maxpixels=2000000, na.color = &quot;#00000000&quot;, map.types = c(&quot;CartoDB.Positron&quot;, &quot;CartoDB.DarkMatter&quot;, &quot;Esri.WorldImagery&quot;), layer.name = c(&quot;pop&quot;, &quot;dist_urban&quot;)) 3.7.3.2 Interactive map of Den Helder mapview(ppi_dhl$data[, , c(&quot;pop&quot;, &quot;dist_urban&quot;)], alpha.regions = 0.6, col.regions = inferno, maxpixels=2000000, na.color = &quot;#00000000&quot;, map.types = c(&quot;CartoDB.Positron&quot;, &quot;CartoDB.DarkMatter&quot;, &quot;Esri.WorldImagery&quot;), layer.name = c(&quot;pop&quot;, &quot;dist_urban&quot;)) "],
["04.Annotate-count-areas.html", "4 Annotating count areas 4.1 Setting up the annotation environment 4.2 Annotate PPIs with waterbird area codes 4.3 Annotate PPIs with point-transect-counts", " 4 Annotating count areas We have data for the following counts provided by Sovon: Waterbird counts with a shapefile containing the surveyed areas and an xlsx file with the count results. Both can be linked using the GEBIEDID contained in both datasets. PTT counts, or point transect counts, contained within an xlsx file with the routes and all bird observations at an \\((X, Y)\\) location. To make processing efficient, we will ‘annotate’ the PPIS with the corresponding area codes for the waterbird counts and some identifier for the PTT counts. Doing so, we can later on calculate relevant count-based parameters (e.g. numbers of birds, average mass, etc.) and ‘join’ these by the corresponding identifiers. 4.1 Setting up the annotation environment library(bioRad) library(sf) library(stars) library(raster) library(dplyr) library(tidyr) library(readr) library(stringr) library(readxl) library(ggplot2) library(viridis) library(fasterize) ppi_hrw &lt;- readRDS(&quot;data/processed/corrected_ppi_hrw_lu.RDS&quot;) ppi_dhl &lt;- readRDS(&quot;data/processed/corrected_ppi_dhl_lu.RDS&quot;) 4.2 Annotate PPIs with waterbird area codes We rename the veriables retained in the shapefile to English and add a numerical wb_area_id which we can use to link the information retained in the shapefiles with the rasterized waterbird areas. All shapefiles are transformed to the CRS of the PPIs. wb_areas &lt;- st_read(&quot;data/raw/sovon/wavo_telgebieden.shp&quot;) %&gt;% rename(wb_area_nr = GEBIEDNR, wb_area_ha = OPPHA, xcoor = XCOOR, ycoor = YCOOR) ## Reading layer `wavo_telgebieden&#39; from data source `/mnt/volume_ams3_01/raw/sovon/wavo_telgebieden.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 4131 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 13551.48 ymin: 307546.8 xmax: 278027 ymax: 622790 ## epsg (SRID): NA ## proj4string: +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs wb_areas$wb_area_id &lt;- seq(1, length(wb_areas$wb_area_nr)) wb_areas_hrw &lt;- st_transform(wb_areas, ppi_hrw$data@proj4string) wb_areas_dhl &lt;- st_transform(wb_areas, ppi_dhl$data@proj4string) We rasterize specifically the newly created wb_area_id (as this is a numerical and not categorical value like wb_area_nr) following the ‘template’ of the existing PPIs. tpl_hrw &lt;- st_as_stars(st_bbox(ppi_hrw$data), dx = ppi_hrw$data@grid@cellsize[1], dy = ppi_hrw$data@grid@cellsize[2], values = NA_real_) tpl_dhl &lt;- st_as_stars(st_bbox(ppi_dhl$data), dx = ppi_dhl$data@grid@cellsize[1], dy = ppi_dhl$data@grid@cellsize[2], values = NA_real_) wb_areas_rasterized_hrw &lt;- st_rasterize(wb_areas_hrw[&quot;wb_area_id&quot;], template = tpl_hrw) wb_areas_rasterized_dhl &lt;- st_rasterize(wb_areas_dhl[&quot;wb_area_id&quot;], template = tpl_dhl) Let’s see how that’s gone so far. par(pty = &quot;s&quot;, mfrow = c(1, 2)) plot(wb_areas_rasterized_hrw, main = &quot;Herwijnen: wb_area_id&quot;) plot(wb_areas_rasterized_dhl, main = &quot;Den Helder: wb_area_id&quot;) Visually that seems to have gone well, now let’s make sure the rasterized waterbird areas share the same features as the PPI ‘rasters’. compareRaster(as(wb_areas_rasterized_hrw, &quot;Raster&quot;), as(ppi_hrw$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) compareRaster(as(wb_areas_rasterized_dhl, &quot;Raster&quot;), as(ppi_dhl$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) ## [1] TRUE ## [1] TRUE Twice a TRUE, so the rasters are identical (except for the values), so we can merge the datasets using a join on the wb_area_id. # Add the wb_area_id to the PPIs ppi_hrw$data$wb_area_id &lt;- unlist(as.data.frame(as(wb_areas_rasterized_hrw, &quot;Raster&quot;))) ppi_dhl$data$wb_area_id &lt;- unlist(as.data.frame(as(wb_areas_rasterized_dhl, &quot;Raster&quot;))) # Join the additional contents of the shapefiles ppi_hrw$data@data %&gt;% left_join(dplyr::select(as.data.frame(wb_areas_hrw), wb_area_id, wb_area_nr, wb_area_ha), by = c(&quot;wb_area_id&quot; = &quot;wb_area_id&quot;)) -&gt; ppi_hrw$data@data ppi_hrw$data$geometry &lt;- NULL ppi_dhl$data@data %&gt;% left_join(dplyr::select(as.data.frame(wb_areas_dhl), wb_area_id, wb_area_nr, wb_area_ha), by = c(&quot;wb_area_id&quot; = &quot;wb_area_id&quot;)) -&gt; ppi_dhl$data@data ppi_dhl$data$geometry &lt;- NULL Let’s verify if that occurred as planned. plot(ppi_hrw, param = &quot;wb_area_id&quot;, zlim = c(min(ppi_hrw$data@data$wb_area_id, na.rm = TRUE), max(ppi_hrw$data@data$wb_area_id, na.rm = TRUE))) plot(ppi_dhl, param = &quot;wb_area_id&quot;, zlim = c(min(ppi_dhl$data@data$wb_area_id, na.rm = TRUE), max(ppi_dhl$data@data$wb_area_id, na.rm = TRUE))) This looks very comparable to the plots of the rasterized scans above and wb_area_id shows similar areas in similar colors, so this worked fine. 4.3 Annotate PPIs with point-transect-counts The PTT point transect counts are organized by routes, which consist of a few points. We can follow the same approach as above with the waterbird counts, by creating coverage shapes (like the shapefile features for the waterbird areas) for each of the routes. Using the convex hull of the points within a route seems like a good starting point to convert these points to areas. However, in that case it would appear as if birds are only counted when looking ‘inwards’ to this shape. By buffering these convex hulls with a radius of the average distance between successive points, a more representative coverage area can be generated. 4.3.1 Loading PTT points We load the PTT data directly from the xlsx file provided by Sovon and rename the variables to English. ptt &lt;- read_excel(&quot;data/raw/sovon/tel_dec_jan_1718.xlsx&quot;, sheet = &quot;ptt&quot;) %&gt;% rename(count_id = tellingid, route = route, count_point = telpunt, season = seizoen, year = teljaar, month = maand, day = dag, species = soort, number = aantal) head(ptt, 10) count_id route count_point season year month day euring species number xcoor ycoor 80917 4 1 2017 2017 12 23 720 Aalscholver 2 246342 520763 80917 4 1 2017 2017 12 23 5920 Zilvermeeuw 18 246342 520763 80917 4 1 2017 2017 12 23 6700 Houtduif 1 246342 520763 80917 4 1 2017 2017 12 23 11870 Merel 4 246342 520763 80917 4 1 2017 2017 12 23 15630 Roek 24 246342 520763 80917 4 2 2017 2017 12 23 6700 Houtduif 1 246357 522178 80917 4 2 2017 2017 12 23 11870 Merel 1 246357 522178 80917 4 2 2017 2017 12 23 15600 Kauw 6 246357 522178 80917 4 2 2017 2017 12 23 15630 Roek 78 246357 522178 80917 4 3 2017 2017 12 23 14620 Pimpelmees 2 246692 523139 As we’re not interested in all the data here, we will load a subset of the columns, specifically all unique combinations of routes and points, which will yield the corresponding xcoor and ycoor coordinates for each count_point within a route. ptt %&gt;% dplyr::select(route, count_point, xcoor, ycoor) %&gt;% group_by(route, count_point) %&gt;% slice(1) -&gt; ptt head(ptt, 10) route count_point xcoor ycoor 4 1 246342 520763 4 2 246357 522178 4 3 246692 523139 4 4 248122 522563 4 5 248249 521818 4 6 248649 523073 4 7 249142 523614 4 8 250073 523534 4 9 252142 523524 4 10 253056 523458 4.3.2 Calculate interpoint distances For each of the routes within the PTT dataset, we will calculate the average distance between the subsequent points, to buffer our convex hull by this value. ptt %&gt;% group_by(route) %&gt;% mutate(xcoor2 = c(xcoor[-1], 0), ycoor2 = c(ycoor[-1], 0)) %&gt;% rowwise() %&gt;% mutate(interpoint_distance = pointDistance(cbind(xcoor, ycoor), cbind(xcoor2, ycoor2), lonlat = FALSE)) %&gt;% ungroup() %&gt;% filter(xcoor2 != 0) %&gt;% # Throw out last point from route where distance to next point is not relevant group_by(route) %&gt;% summarise(avg_interpoint_distance = mean(interpoint_distance)) -&gt; ptt_interpoint_distances ptt %&gt;% left_join(ptt_interpoint_distances, by = c(&quot;route&quot; = &quot;route&quot;)) -&gt; ptt head(ptt, 10) route count_point xcoor ycoor avg_interpoint_distance 4 1 246342 520763 1162.042 4 2 246357 522178 1162.042 4 3 246692 523139 1162.042 4 4 248122 522563 1162.042 4 5 248249 521818 1162.042 4 6 248649 523073 1162.042 4 7 249142 523614 1162.042 4 8 250073 523534 1162.042 4 9 252142 523524 1162.042 4 10 253056 523458 1162.042 We can now calculate the convex hulls of the points grouped by route. ptt %&gt;% st_as_sf(coords = c(&quot;xcoor&quot;, &quot;ycoor&quot;), crs = 28992) %&gt;% st_transform(crs = ppi_hrw$data@proj4string) %&gt;% group_by(route, avg_interpoint_distance) %&gt;% summarise() %&gt;% st_convex_hull() -&gt; ptt_convex_hulls_hrw ptt %&gt;% st_as_sf(coords = c(&quot;xcoor&quot;, &quot;ycoor&quot;), crs = 28992) %&gt;% # original CRS = EPSG:28992 (RD New) st_transform(crs = ppi_dhl$data@proj4string) %&gt;% group_by(route, avg_interpoint_distance) %&gt;% summarise() %&gt;% st_convex_hull() -&gt; ptt_convex_hulls_dhl plot(ptt_convex_hulls_hrw[1], main = &quot;PTT Routes Herwijnen: Route&quot;) plot(ptt_convex_hulls_hrw[2], main = &quot;PTT Routes Herwijnen: Avg interpoint dist.&quot;) plot(ptt_convex_hulls_dhl[1], main = &quot;PTT Routes Den Helder: Route&quot;) plot(ptt_convex_hulls_dhl[2], main = &quot;PTT Routes Den Helder: Avg interpoint dist.&quot;) As we have calculated the average distance between the points, we can now buffer the convex hulls by this value to attain more representative sizes of the covered areas. ptt_convex_hulls_hrw %&gt;% st_buffer(dist = as.double(ptt_convex_hulls_hrw$avg_interpoint_distance)) -&gt; ptt_convex_hulls_hrw ptt_convex_hulls_dhl %&gt;% st_buffer(dist = as.double(ptt_convex_hulls_dhl$avg_interpoint_distance)) -&gt; ptt_convex_hulls_dhl plot(ptt_convex_hulls_hrw[1], main = &quot;Buffered PTT Routes Herwijnen&quot;) plot(ptt_convex_hulls_dhl[1], main = &quot;Buffered PTT Routes Den Helder&quot;) Now that is taken care of, we can rasterize the polygons using the fasterize package. As there is overlap between the areas covered by the routes using the convex hulls and a raster can only contain a single value for every pixel, we need to resolve this overlap. In this case we will compare overlapping areas and pick those where the average distance between the points for that area is lowest. This biases towards counts that cover a smaller area, so probably resulting in more accurate estimates of birds around. ptt_hrw &lt;- raster(ppi_hrw$data) ptt_dhl &lt;- raster(ppi_dhl$data) ptt_hrw &lt;- fasterize(ptt_convex_hulls_hrw, ptt_hrw, field = &quot;route&quot;, by = &quot;avg_interpoint_distance&quot;) ptt_dhl &lt;- fasterize(ptt_convex_hulls_dhl, ptt_dhl, field = &quot;route&quot;, by = &quot;avg_interpoint_distance&quot;) ptt_hrw &lt;- suppressWarnings(stackApply(ptt_hrw, indices = rep(1, length(ptt_hrw)), fun = min, na.rm = TRUE)) ptt_dhl &lt;- suppressWarnings(stackApply(ptt_dhl, indices = rep(1, length(ptt_dhl)), fun = min, na.rm = TRUE)) plot(ptt_hrw, main = &quot;Rasterized PTT routes Herwijnen&quot;) plot(ptt_dhl, main = &quot;Rasterized PTT routes Den Helder&quot;) This approach to solving the issue of overlapping polygons introduces a possible problem here, where it will eventually result in larger numbers of birds (corresponding to a single route) being spread over a smaller area of land (after the overlap is removed from some polygons). However, I don’t really see an alternative solution to this problem, except by averaging the numbers of birds over the whole area covered by the PTT counts. This would result in much less flexibility later on when calculating relevant bird parameters, so for now we leave it as is. With the rasterization done, let’s compare the resultant raster and see if it is identical to the PPIs. compareRaster(as(ptt_hrw, &quot;Raster&quot;), as(ppi_hrw$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) compareRaster(as(ptt_dhl, &quot;Raster&quot;), as(ppi_dhl$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) ## [1] TRUE ## [1] TRUE Two TRUEs, so that’s excellent. We can now add the ptt_route to the PPIs. ppi_hrw$data$ptt_route &lt;- unlist(as.data.frame(as(ptt_hrw, &quot;Raster&quot;))) ppi_dhl$data$ptt_route &lt;- unlist(as.data.frame(as(ptt_dhl, &quot;Raster&quot;))) Let’s verify once again if that occurred as planned. plot(ppi_hrw, param = &quot;ptt_route&quot;, zlim = c(min(ppi_hrw$data@data$ptt_route, na.rm = TRUE), max(ppi_hrw$data@data$ptt_route, na.rm = TRUE))) plot(ppi_dhl, param = &quot;ptt_route&quot;, zlim = c(min(ppi_dhl$data@data$ptt_route, na.rm = TRUE), max(ppi_dhl$data@data$ptt_route, na.rm = TRUE))) "],
["References.html", "5 References", " 5 References "]
]
