[
["index.html", "Fireworks Preface Abstract How to use this document", " Fireworks Bart Hoekstra 2020-03-10 Preface Abstract How to use this document Knit it Use the following line in the console or click Build Book in RStudio. bookdown::render_book(input = &quot;index.Rmd&quot;, output_format = &quot;bookdown::gitbook&quot;, clean = TRUE) Full-reproduction mode In the spirit of reproducibility, the entire analysis, which happens to be contained in this book, can be reproduced at the push of a button (almost). To facilitate faster reproduction, some code chunks are only run when full-reproduction mode is switched on. This can be done by setting the R variable full_repro to TRUE in build_bookdown.R. "],
["01.Selecting-take-off-moments.html", "1 Selecting firework take-off moment 1.1 Setting up the processing environment 1.2 Calculate the vertical profiles 1.3 Generate time series of vertical profiles 1.4 Identifying moment of take-off", " 1 Selecting firework take-off moment For this study we select the moment of ‘en masse’ take-off of birds at the turn of the year. To make sure birds are still fairly ‘close’ to the take-off habitat, we therefore pick the moment where the increase in VIR (Vertically Integrated Reflectivity) is the highest. Based on experience, one would expect this to occur between 00:05 and 00:15 on January 1st, as people tend to light the fireworks right after they have shared New Year’s wishes with each other. 1.1 Setting up the processing environment We use vol2bird included in the bioRad package (Dokter et al. 2019) to calculate the vertical profiles of reflectivity, from which we determine the exact take off moment of birds. This implies we assume birds take to the skies everywhere simultaneously, but that seems a realistic assumption given that the lighting of fireworks is synchronised by the local time, rather than the time of sunset/sunrise. library(bioRad) library(ggplot2) library(dplyr) library(tidyr) Sys.setenv(TZ = &quot;UTC&quot;) 1.2 Calculate the vertical profiles We calculate vertical profiles for the period between December 31st, 2017 22:00 and 01:00 UTC on January 1st, 2018, which corresponds with 23:00 til 02:00 local Amsterdam time (UTC + 1). It is not necessary to generate so many vp files, but it gives a better temporal overview if we add some ‘temporal padding’ around the fireworks event. Beware: to calculate the vertical profiles, a running instance of Docker is required. This code chunk will only run in full-reproduction mode. fireworks_scans &lt;- Sys.glob(file.path(&quot;data/raw/pvol/fireworks-2017-2018&quot;, &quot;*_ODIM.h5&quot;)) cat(&quot;Files left to process: &quot;, length(fireworks_scans), &quot;\\n&quot;) i = 1 for (scan in fireworks_scans) { if (i %% 5 == 0) { cat(i, &quot;... &quot;) } vpfile_out &lt;- sub(&quot;raw/pvol/fireworks-2017-2018&quot;, &quot;processed/vp/fireworks-2017-2018&quot;, scan) try(calculate_vp(scan, vpfile = vpfile_out, verbose = FALSE, mount = dirname(fireworks_scans[1]))) i = i + 1 } 1.3 Generate time series of vertical profiles We can now generate a time series of vertical profiles and plot the bird densities to get an idea of what was going on during NYE of 2017-2018. fw_hrw_vpts &lt;- Sys.glob(file.path(&quot;data/processed/vp/fireworks-2017-2018&quot;, &quot;*NL62*&quot;)) %&gt;% read_vpfiles() %&gt;% bind_into_vpts() %&gt;% regularize_vpts(interval = &quot;auto&quot;) ## projecting on 300 seconds interval grid... fw_dhl_vpts &lt;- Sys.glob(file.path(&quot;data/processed/vp/fireworks-2017-2018&quot;, &quot;*NL61*&quot;)) %&gt;% read_vpfiles() %&gt;% bind_into_vpts() %&gt;% regularize_vpts(interval = &quot;auto&quot;) ## projecting on 300 seconds interval grid... start &lt;- as.POSIXct(&quot;2017-12-31 22:00:00&quot;) end &lt;- as.POSIXct(&quot;2018-01-01 01:00:00&quot;) indexes_hrw &lt;- which(fw_hrw_vpts$datetime &gt;= start &amp; fw_hrw_vpts$datetime &lt;= end) indexes_dhl &lt;- which(fw_dhl_vpts$datetime &gt;= start &amp; fw_dhl_vpts$datetime &lt;= end) # Should mostly be identical title_hrw &lt;- expression(&quot;Herwijnen: volume density [#/km&quot;^3 * &quot;]&quot;) title_dhl &lt;- expression(&quot;Den Helder: volume density [#/km&quot;^3 * &quot;]&quot;) plot(fw_hrw_vpts[indexes_hrw], main = title_hrw) plot(fw_dhl_vpts[indexes_dhl], main = title_dhl) Both plots for Herwijnen and Den Helder show exactly what we would expect: fairly low densities of birds aloft leading up to midnight (23:00 CET), then suddenly a strong increase of birds right after midnight. For Herwijnen this peak is much more pronounced than for Den Helder, probably due to the different surroundings of the radar. As vol2bird only takes into account rangegates within 5-35km of the radar, in the case of Den Helder this contains a lot more sea surface, from which fewer birds can be expected to take off than from land. 1.4 Identifying moment of take-off We integrate the time series of vertical profiles, so we can calculate the vir derivatives and determine in what volume scan birds really take to the skies for each radar separately. integrated_hrw &lt;- integrate_profile(fw_hrw_vpts) integrated_dhl &lt;- integrate_profile(fw_dhl_vpts) integrated_hrw$vir_deriv &lt;- c(NA, diff(integrated_hrw$vir, 1)) integrated_dhl$vir_deriv &lt;- c(NA, diff(integrated_dhl$vir, 1)) integrated_hrw$radar &lt;- &quot;Herwijnen&quot; integrated_dhl$radar &lt;- &quot;Den Helder&quot; integrated &lt;- rbind(integrated_hrw, integrated_dhl) integrated_l &lt;- integrated %&gt;% pivot_longer(-c(&quot;datetime&quot;, &quot;radar&quot;), names_to = &quot;variable&quot;, values_to = &quot;value&quot;) %&gt;% filter(variable == &quot;vir&quot; | variable == &quot;vir_deriv&quot;) %&gt;% filter(datetime &gt;= start &amp; datetime &lt;= end) max_vir_deriv &lt;- integrated_l %&gt;% group_by(variable, radar) %&gt;% filter(variable == &quot;vir_deriv&quot;) %&gt;% summarize(max_value = max(value), datetime = datetime[which.max(value)]) %&gt;% arrange(radar) # Sort so order remains the same theme_set(theme_bw()) ggplot(integrated_l, aes(x = datetime)) + geom_line(aes(y = value, colour = radar, linetype = variable)) + scale_x_datetime(breaks = &quot;10 min&quot;, date_labels = &quot;%H:%M&quot;, expand = c(0, 0)) + scale_color_manual(values = c(&quot;blue&quot;, &quot;red&quot;)) + scale_linetype_discrete(name = &quot;Line type&quot;, labels = c(&quot;VIR&quot;, expression(paste(Delta,&quot;VIR/scan&quot;)))) + labs(title = &quot;Time series of Vertically Integrated Reflectivities (VIR)&quot;, subtitle = &quot;NYE 2017-2018&quot;, x = &quot;Time (CET)&quot;, y = &quot;VIR&quot;, colour = &quot;Radar&quot;, linetype = &quot;Linetype&quot;) + theme(axis.text.x = element_text(angle = -90), panel.grid.minor = element_blank()) The plot shows \\(\\Delta VIR/{scan}\\) peaks earlier for the Den Helder radar than for Herwijnen, but both at roughly the same level of 1066 and 991 respectively. We can now identify which scans ‘contain’ the moment of take-off. The datetime values correspond with the start times of the scans and the filenames of the polar volume files. max_vir_deriv[, 2:4] radar max_value datetime Den Helder 1066.0071 2017-12-31 23:05:04 Herwijnen 991.1317 2017-12-31 23:10:04 pvol_folder &lt;- &quot;data/raw/pvol/fireworks-2017-2018/&quot; hrw_dt_str &lt;- strftime(max_vir_deriv[[2, 4]], format = &quot;%Y%m%d%H%M&quot;) dhl_dt_str &lt;- strftime(max_vir_deriv[[1, 4]], format = &quot;%Y%m%d%H%M&quot;) pvol_hrw_path &lt;- paste(pvol_folder, &quot;RAD_NL62_VOL_NA_&quot;, hrw_dt_str, &quot;_ODIM.h5&quot;, sep = &quot;&quot;) pvol_dhl_path &lt;- paste(pvol_folder, &quot;RAD_NL61_VOL_NA_&quot;, dhl_dt_str, &quot;_ODIM.h5&quot;, sep = &quot;&quot;) save(pvol_hrw_path, pvol_dhl_path, file = &quot;data/processed/pvol_selection.RData&quot;) So we will continue using the following files in this study: Herwijnen: RAD_NL62_VOL_NA_201712312310_ODIM.h5 Den Helder: RAD_NL61_VOL_NA_201712312305_ODIM.h5 References "],
["02.Radar-data-preprocessing.html", "2 Radar Data Preprocessing 2.1 Setting-up the pre-processing environment 2.2 Removing electromagnetic interference 2.3 Filter meteorology using the depolarization ratio 2.4 Remove classified precipitation from polar volumes 2.5 Filter ground clutter 2.6 Range-bias correction 2.7 Distance to radar 2.8 Preprocess additional scans", " 2 Radar Data Preprocessing Weather radar data of the firework events at the turns of the years usually contain some degree of precipitation clutter. To filter out precipitation advanced algorithms such as MistNet have been developed, but as we are dealing with dual-pol data here, we can use a simpler and yet robust method using the depolarization ratio (Kilambi, Fabry, and Meunier 2018). To make sure our processed weather radar data does not contain any significant proportions of precipitation or ground clutter anymore, we process the data as follows: We remove electromagnetic interference based on a visual inspection of the scan and throw out all data of affected rays. We calculate the depolarization ratio (Kilambi, Fabry, and Meunier 2018) and separate biology from meteorology by classifying all range gates with a depolarization ratio \\(&gt;-12dB\\) as biology. We subsequently ‘despeckle’ this, to remove obvious misclassifications. We average reflectivity over a number of scans before the time of the fireworks event and throw out the range-gates with highest average reflectivities. All these steps can be undertaken directly on the polar volume data, so we can subsequently directly plug the cleaned up volume into the range-bias correction. 2.1 Setting-up the pre-processing environment As usual, we use bioRad (Dokter et al. 2019), but this time we include plotly for some interactive plotting. library(bioRad) library(plotly) library(gridExtra) library(ggpubr) library(mapview) library(viridis) library(raster) 2.2 Removing electromagnetic interference We have determined in which scans birds are taking off based on the maximum increase in reflectivity in the scan for each of the involved radars. Let’s now look at these scans to see how much filtering for electromagnetic interference we need to do. The easiest way to determine which rays are subject to this interference is by plotting the scans in polar coordinates (\\((r, \\alpha)\\)), so interference stands out as horizontal lines of more or less constant, or very gradually changing reflectivities. Plotting using plotly makes it easier to identify the specific problematic rays as one can zoom in to identify the exact azimuths \\(\\alpha\\). The scans we will be using: Herwijnen: RAD_NL62_VOL_NA_201712312310_ODIM.h5 Den Helder: RAD_NL61_VOL_NA_201712312305_ODIM.h5 For illustrative purposes we will only illustrate removal of EM interference for the Herwijnen, as the procedure for Den Helder is exactly identical, but this scan contains very little of said clutter. pvol_hrw &lt;- read_pvolfile(pvol_hrw_path, param = &quot;all&quot;) pvol_dhl &lt;- read_pvolfile(pvol_dhl_path, param = &quot;all&quot;) scan &lt;- plot(pvol_hrw$scans[[1]], param = &quot;DBZH&quot;, xlim = c(0, 180000)) + theme_dark() ggplotly(scan) Right away we can see that rays at two places in the scan are subject to electromagnetic interference. This is probably most problematic in the lowest elevations of the volume scan, but nevertheless each of the length(pvol_hrw$scans) scans have be checked manually. Doing so results in the identification of the following rays that contain electromagnetic interference (ei_rays), organised in a list with the scan numbers (organised ascendingly per elevation angle) as keys. Admittedly: there is another ray that seems to contain interference in the first scan, but this is so far away from the radar (150km+) it should not affect our results as no meaningful numbers of birds can be detected at that range anyways. Similarly, there are similar patterns of interference/clutter in higher elevation scans, but these too should not affect our results. ei_rays_hrw &lt;- list(c(201, 202, 214, 215), # scan 1 c(201, 202, 214, 215), # scan 2 c(201, 202, 214, 215), # scan 3 c(202, 214, 215)) # scan 4 names(ei_rays_hrw) &lt;- c(1, 2, 3, 4) ei_rays_dhl &lt;- list(c(60, 61)) # scan 1 names(ei_rays_dhl) &lt;- c(1) We can now remove the data for the affected rays in the corresponding scans by setting the values to NA (see R/remove_rays.R). source(&quot;R/remove_rays.R&quot;) pvol_hrw &lt;- remove_rays(pvol_hrw, rays = ei_rays_hrw) pvol_dhl &lt;- remove_rays(pvol_dhl, rays = ei_rays_dhl) 2.2.1 Verify removal of rays with EM interference If removal is correct, the \\((r,\\alpha)\\) plots should not show clear horizontal structures anymore. i = 1 plot(pvol_hrw$scans[[i]], param = &quot;DBZH&quot;, xlim = c(0, 180000)) + theme_dark() + labs(title = &quot;Herwijnen: Cleaned from EM interference&quot;, subtitle = paste(&quot;Elevation:&quot;, round(pvol_hrw$scans[[i]]$attributes$where$elangle, 1))) plot(pvol_dhl$scans[[i]], param = &quot;DBZH&quot;, xlim = c(0, 180000)) + theme_dark() + labs(title = &quot;Den Helder: Cleaned from EM interference&quot;, subtitle = paste(&quot;Elevation:&quot;, round(pvol_dhl$scans[[i]]$attributes$where$elangle, 1))) Well, that seems to work nicely. The remaining bits of clutter won’t affect the results much as they cover fairly small areas and consistently appear at longer distances away from the radar, where birds are difficult to detect anyways. 2.3 Filter meteorology using the depolarization ratio Meteorology can be filtered using the depolarization ratio following Kilambi et al. (2018). We calculate the depolarization ratio for the raw pvol data after EM interference has been removed and subsequently ‘despeckle’ the results to improve the classification. Despeckling works by comparing the classification of the majority of the neighbourhood rangegates with the classification of the center rangegate, and changing the latter to reflect the majority of the neighbourhood classification if there is a difference. We define the ‘neighbourhood’ as a \\(3^{\\circ}\\) by \\(3 \\times rscale\\) area centered around a focal rangegate (3 rangegates in azimuth \\(\\times\\) 3 rangegates in range) . Selecting the rangegates while taking the sphericity of the radar scan into account (e.g. ray 360 should be directly adjacent to ray 1) is made easier with the R/window_coords.R function. The despeckling is implemented in R/despeckle_scan_logical.R. With the despeckling algorithm in place, we can: Calculate the depolarization ratio (DPR). Classify biology as rangegates where DPR &gt; -12 and store this classification as BIOLR (Biology Raw) scan parameter in the pvol object. Despeckle the classification and store the outcome in the BIOLD (Biology Despeckled) scan parameter in the pvol object. source(&quot;R/window_coords.R&quot;) source(&quot;R/despeckle_scan_logical.R&quot;) # Calculate depolarization ratio, classify and despeckle biology classifications for the entire volume calculate_dpr &lt;- function(pvol){ for (i in seq_along(pvol$scans)) { # Calculate ZDR as ZDR = DBZH - DBZV pvol$scans[[i]]$params$ZDR &lt;- pvol$scans[[i]]$params$DBZH - pvol$scans[[i]]$params$DBZV attributes(pvol$scans[[i]]$params$ZDR)$param &lt;- &quot;ZDR&quot; # Calculate depolarization ratio zdr_linear &lt;- 10 ** (pvol$scans[[i]]$params$ZDR / 10) dpr_linear &lt;- (zdr_linear + 1 - 2 * sqrt(zdr_linear) * pvol$scans[[i]]$params$RHOHV) / (zdr_linear + 1 + 2 * sqrt(zdr_linear) * pvol$scans[[i]]$params$RHOHV) pvol$scans[[i]]$params$DPR &lt;- 10 * log10(dpr_linear) attributes(pvol$scans[[i]]$params$DPR)$param &lt;- &quot;DPR&quot; # Classify based on depolarization ratio biology &lt;- (pvol$scans[[i]]$params$DPR &gt; -12) * 1 # multiply by 1 to convert TRUE/FALSE to 1/0 class(biology) &lt;- c(&quot;param&quot;, &quot;matrix&quot;) attributes(biology) &lt;- attributes(pvol$scans[[i]]$params$DPR) # copy attributes from DPR attributes(biology)$param &lt;- &quot;BIOLR&quot; pvol$scans[[i]]$params$BIOLR &lt;- biology # Despeckle biology classification pvol$scans[[i]]$params$BIOLD &lt;- pvol$scans[[i]]$params$BIOLR pvol$scans[[i]]$params$BIOLD &lt;- despeckle_scan_logical(pvol$scans[[i]]$params$BIOLD) attributes(pvol$scans[[i]]$params$BIOLD)$param &lt;- &quot;BIOLD&quot; } return(pvol) } pvol_hrw &lt;- suppressWarnings(calculate_dpr(pvol_hrw)) # Will throw NaN warnings if not suppressed pvol_dhl &lt;- suppressWarnings(calculate_dpr(pvol_dhl)) 2.3.1 Verify DPR-based classification Now let’s plot some PPIs to verify the accuracy of DPR-based classification and the subsequent despeckling, by plotting DBZH, VRADH, DPR, BIOLR and BIOLD. source(&quot;R/side_by_side_ppi.R&quot;) side_by_side_ppi(pvol_hrw, pvol_dhl, &quot;Herwijnen&quot;, &quot;Den Helder&quot;, params = c(&quot;DBZH&quot;, &quot;VRADH&quot;, &quot;DPR&quot;, &quot;BIOLR&quot;, &quot;BIOLD&quot;)) The plots show accurate classification of the obvious precipitation zones, except at the edges of these echoes, where BIOLD is a vast improvement over BIOLR, showing the value of despeckling. Similarly, there is a lot of ‘noise’ where birds should be, but despeckling takes care of most of that quite nicely as well. Additionally, it shows a pattern we would expect to see: at closer distances to the radar most ‘speckles’ that are not near to precipitation zones are turned into biology, and at distances further from the radar they are more often ‘flipped’ to meteorology. This method may not be perfect, but it classifies birds quite conservatively. The few misclassifications that remain should not affect the results so much, as they are few in number and do not occur at the centers of precipitation echoes, so they are not likely to turn into numerical outliers. 2.4 Remove classified precipitation from polar volumes Now that we have accurate classifications of the rangegates based on depolarization ratios, we can start to remove the precipitation from the polar volumes, to retain a scan that comprises of only birds (with a few occasional misclassifications). As there are areas where DPR and DBZH do not overlap, we also have to remove all rangegates that are not classified. source(&quot;R/remove_precipitation.R&quot;) pvol_hrw &lt;- remove_precipitation(pvol_hrw) pvol_dhl &lt;- remove_precipitation(pvol_dhl) Plotting the same PPIs as before should now show a cleaned-up/precipitation-free scan next to the classifications. side_by_side_ppi(pvol_hrw, pvol_dhl, &quot;Herwijnen&quot;, &quot;Den Helder&quot;, params = c(&quot;DBZH&quot;, &quot;VRADH&quot;)) That looks very good for both Herwijnen and Den Helder radars, but for the latter we have a lot of sea clutter that still needs to be removed, but that will come when ground clutter is filtered. 2.5 Filter ground clutter We will filter out ground clutter by calculating summary statistics of the rangegate reflectivities over: The 36 scans preceding the scans selected for the study of the fireworks event (= 3 hours worth of scans). A day of clear weather closest to the 31st of December 2017. For each we will filter ground clutter based on the mean DBZH values. Using the variance and mad of the DBZH was tested, but has a few difficulties: variance is very sensitive to the outliers caused by rangegates with NA values (detection below the ‘mds’, the minimum detectable signal) occasionally flipping over to a noisy measurement, resulting in very high variances. mad is much more robust to outliers, but to compute these values we need to set NA cells to the ‘mds’ (minimum detectable signal), which will result in mad values close to, or exactly 0 for cells that never reflected as well as true static clutter, so it’s difficult to separate those. Finally, a visual inspection showed the mean and mad of DBZH (assuming one could overcome the aforementioned problem with the latter) do not differ much, but the mean is somewhat more ‘aggressive’ in filtering, which in this case is quite good. Combining the clutter removal based on a clear day as well as the 36 preceding scans lets us account for both truly static clutter (e.g. buildings) as well as clutter that is more dynamic such as sea and wind park clutter, without also requiring us to resort to filtering of dynamic clutter using a VRADH threshold. The quality of filtering is assessed visually. 2.5.1 Dynamic clutter We select 36 (3 hours worth of scans) preceding the start of the fireworks (23:00 UTC) and add an additional margin of 3 scans (15 minutes of scans) as that the VIR plots in the previous chapter have shown numbers of birds aloft are very low and stable up to that period. available_scans_hrw &lt;- Sys.glob(file.path(&quot;data/raw/pvol/clutter-removal-20171231&quot;, &quot;*NL62*20171231*&quot;)) available_scans_dhl &lt;- Sys.glob(file.path(&quot;data/raw/pvol/clutter-removal-20171231&quot;, &quot;*NL61*20171231*&quot;)) fw_start_hrw_pvol_path &lt;- &quot;data/raw/pvol/fireworks-2017-2018/RAD_NL62_VOL_NA_201712312300_ODIM.h5&quot; fw_start_dhl_pvol_path &lt;- &quot;data/raw/pvol/fireworks-2017-2018/RAD_NL61_VOL_NA_201712312300_ODIM.h5&quot; selected_scan_hrw &lt;- sub(&quot;fireworks-2017-2018&quot;, &quot;clutter-removal-20171231&quot;, fw_start_hrw_pvol_path) selected_scan_dhl &lt;- sub(&quot;fireworks-2017-2018&quot;, &quot;clutter-removal-20171231&quot;, fw_start_dhl_pvol_path) selected_scan_id_hrw &lt;- match(selected_scan_hrw, available_scans_hrw) selected_scan_id_dhl &lt;- match(selected_scan_dhl, available_scans_dhl) usable_scans_hrw &lt;- available_scans_hrw[(selected_scan_id_hrw-dynamic_time_margin-dynamic_nr_preceding_scans+1): (selected_scan_id_hrw-dynamic_time_margin)] usable_scans_dhl &lt;- available_scans_dhl[(selected_scan_id_dhl-dynamic_time_margin-dynamic_nr_preceding_scans+1): (selected_scan_id_dhl-dynamic_time_margin)] We can now loop over the files one by one and stack reflectivity data (DBZH) — after filtering out precipitation — in a multidimensional array. Note: the following code chunk will only run in full-reproduction mode as it takes quite a lot of time. Results are saved, so the next iteration this chunk can be skipped. source(&quot;R/stack_rainfree_reflectivities.R&quot;) stack_rainfree_reflectivities(usable_scans_hrw, outputfile = &quot;data/processed/clutter_dynamic_hrw.RDS&quot;) stack_rainfree_reflectivities(usable_scans_dhl, outputfile = &quot;data/processed/clutter_dynamic_dhl.RDS&quot;) With all DBZH compiled in a single multidimensional array, we can calculate mean reflectivity, which we store as DBZH_AVG in a pvol that now contains the dynamic clutter map. pvol_clutter_dynamic_hrw &lt;- readRDS(&quot;data/processed/clutter_dynamic_hrw.RDS&quot;) pvol_clutter_dynamic_dhl &lt;- readRDS(&quot;data/processed/clutter_dynamic_dhl.RDS&quot;) source(&quot;R/calculate_reflectivity_stack_mean.R&quot;) pvol_clutter_dynamic_hrw &lt;- calculate_reflectivity_stack_mean(pvol_clutter_dynamic_hrw, mds) pvol_clutter_dynamic_dhl &lt;- calculate_reflectivity_stack_mean(pvol_clutter_dynamic_dhl, mds) saveRDS(pvol_clutter_dynamic_hrw, &quot;data/processed/clutter_dynamic_hrw_avg.RDS&quot;) saveRDS(pvol_clutter_dynamic_dhl, &quot;data/processed/clutter_dynamic_dhl_avg.RDS&quot;) pvol_clutter_dynamic_hrw &lt;- readRDS(&quot;data/processed/clutter_dynamic_hrw_avg.RDS&quot;) pvol_clutter_dynamic_dhl &lt;- readRDS(&quot;data/processed/clutter_dynamic_dhl_avg.RDS&quot;) 2.5.1.1 Verify dynamic clutter map Let’s see what that looks like on a basemap, using a DBZH_AVG threshold of \\(-10dbZ\\), following (Dokter et al. 2011). scan_hrw &lt;- pvol_clutter_dynamic_hrw$scans[[1]] scan_dhl &lt;- pvol_clutter_dynamic_dhl$scans[[1]] side_by_side_ppi(pvol_clutter_dynamic_hrw, pvol_clutter_dynamic_dhl, &quot;Herwijnen dynamic clutter&quot;, &quot;Den Helder dynamic clutter&quot;, params = &quot;DBZH_AVG&quot;, range_max = 50000, scan_id = 1, basemap = TRUE, zlim = c(-11, -10)) Visually assessing this clutter map shows that it works quite well, selecting e.g. areas with wind parks, sea clutter, high buildings, industry, etc. Exactly what we hoped to achieve. 2.5.2 Static clutter Now, let’s retry exactly the same procedure, but this time selecting a day with no precipitation, which can be done using this tool by KNMI, so we can filter for truly static clutter. We select the following days: Herwijnen: December 29th, 2017 Den Helder: December 25th, 2017 Note: the following code chunk will only run in full-reproduction mode as it takes a lot of time to run. Results are saved, so the next iteration this chunk can be skipped. source(&quot;R/stack_rainfree_reflectivities.R&quot;) available_scans_hrw &lt;- Sys.glob(file.path(&quot;data/raw/pvol/clutter-removal-20171229-hrw&quot;, &quot;*NL62*20171229*&quot;)) available_scans_dhl &lt;- Sys.glob(file.path(&quot;data/raw/pvol/clutter-removal-20171225-dhl&quot;, &quot;*NL61*20171225*&quot;)) stack_rainfree_reflectivities(available_scans_hrw, outputfile = &quot;data/processed/clutter_static_hrw.RDS&quot;) stack_rainfree_reflectivities(available_scans_dhl, outputfile = &quot;data/processed/clutter_static_dhl.RDS&quot;) And we calculate mean DBZH values (DBZH_AVG). pvol_clutter_static_hrw &lt;- readRDS(&quot;data/processed/clutter_static_hrw.RDS&quot;) pvol_clutter_static_dhl &lt;- readRDS(&quot;data/processed/clutter_static_dhl.RDS&quot;) source(&quot;R/calculate_reflectivity_stack_mean.R&quot;) # Source because full_repro may be set to FALSE pvol_clutter_static_hrw &lt;- calculate_reflectivity_stack_mean(pvol_clutter_static_hrw, mds) pvol_clutter_static_dhl &lt;- calculate_reflectivity_stack_mean(pvol_clutter_static_dhl, mds) saveRDS(pvol_clutter_static_hrw, &quot;data/processed/clutter_static_hrw_avg.RDS&quot;) saveRDS(pvol_clutter_static_dhl, &quot;data/processed/clutter_static_dhl_avg.RDS&quot;) pvol_clutter_static_hrw &lt;- readRDS(&quot;data/processed/clutter_static_hrw_avg.RDS&quot;) pvol_clutter_static_dhl &lt;- readRDS(&quot;data/processed/clutter_static_dhl_avg.RDS&quot;) 2.5.2.1 Verify static clutter map Let’s see what that looks like on a basemap, using a DBZH_AVG threshold of \\(-10dbZ\\), following (Dokter et al. 2011). scan_hrw &lt;- pvol_clutter_static_hrw$scans[[1]] scan_dhl &lt;- pvol_clutter_static_dhl$scans[[1]] side_by_side_ppi(pvol_clutter_static_hrw, pvol_clutter_dynamic_dhl, &quot;Herwijnen static clutter&quot;, &quot;Den Helder static clutter&quot;, params = &quot;DBZH_AVG&quot;, range_max = 50000, scan_id = 1, basemap = TRUE, zlim = c(-11, -10)) 2.5.3 Remove dynamic and static clutter Now that we have identified both dynamic and static clutter, we can create the final cleaned up polar volume. source(&quot;R/remove_groundclutter.R&quot;) pvol_hrw &lt;- remove_groundclutter(remove_groundclutter(pvol_hrw, pvol_clutter_dynamic_hrw), pvol_clutter_static_hrw) pvol_dhl &lt;- remove_groundclutter(remove_groundclutter(pvol_dhl, pvol_clutter_dynamic_dhl), pvol_clutter_static_dhl) saveRDS(pvol_hrw, file = &quot;data/processed/pvol_clean_hrw.RDS&quot;) saveRDS(pvol_dhl, file = &quot;data/processed/pvol_clean_dhl.RDS&quot;) 2.6 Range-bias correction With all identifiable sources of clutter removed from the raw polar volume, we can apply the range-bias correction (Kranstauber et al. 2020). For this it is necessary to calculate the local vertical profile for each of the radars. Ideally, this would be done using the filtered pvol we have now generated, but the vol2bird algorithm (Dokter et al. 2011) only takes pvol files as input, rather than R objects. As there is no implementation of a converter yet, for now a vp of the raw pvol files will have to do. As there is no precipitation within the relevant distance to the radars (5-35km), the calculated vp based on the raw pvol files should not differ wildly from that of the filtered pvol R object we have generated in the previous steps. For the Den Helder radar we calculate the vp by setting azimuthal limits to cover the mainland of North Holland, rather than the whole radar domain, as the latter will result in vps that underestimate the true density of birds aloft. See Appendix [generating-vps-for-den-helder-radar] for a more detailed explanation. vp_hrw &lt;- calculate_vp(file = pvol_hrw_path, vpfile = paste(&quot;data/processed/vp/&quot;, basename(pvol_hrw_path), sep = &quot;&quot;), verbose = FALSE) vp_dhl &lt;- calculate_vp(file = pvol_dhl_path, vpfile = paste(&quot;data/processed/vp/&quot;, basename(pvol_dhl_path), sep = &quot;&quot;), verbose = FALSE, azim_min = 90, azim_max = 200) corrected_ppi_hrw &lt;- integrate_to_ppi(pvol_hrw, vp_hrw, res = 500, xlim = c(-150000, 150000), ylim = c(-150000, 150000)) corrected_ppi_dhl &lt;- integrate_to_ppi(pvol_dhl, vp_dhl, res = 500, xlim = c(-150000, 150000), ylim = c(-150000, 150000)) saveRDS(corrected_ppi_hrw, file = &quot;data/processed/corrected_ppi_hrw.RDS&quot;) saveRDS(corrected_ppi_dhl, file = &quot;data/processed/corrected_ppi_dhl.RDS&quot;) We can now plot the final range-corrected PPIs. p_vir_hrw &lt;- plot(corrected_ppi_hrw, param = &quot;VIR&quot;, zlim = c(0, 20000)) + labs(title = &quot;Herwijnen: VIR&quot;) p_vir_dhl &lt;- plot(corrected_ppi_dhl, param = &quot;VIR&quot;, zlim = c(0, 20000)) + labs(title = &quot;Den Helder: VIR&quot;) ggarrange(p_vir_hrw, p_vir_dhl, ncol = 2, nrow = 1, common.legend = TRUE, legend = &quot;right&quot;) It’s a little hard to interpret with the PPI pixels that contain no birds set to 0 and no landscape below, so let’s see what it looks like on a basemap. As there are some ships out at the North Sea causing reflectivities orders of magnitude higher and thus stretching the colormap, we — for now — need to ‘clip’ these values to a maximum set at the value of the 99th percentile. source(&quot;R/clip.R&quot;) filtered_corrected_ppi_hrw &lt;- corrected_ppi_hrw filtered_corrected_ppi_hrw$data@data &lt;- as.data.frame(apply(filtered_corrected_ppi_hrw$data@data, 2, clip, bounds = c(0.05, 0.99))) filtered_corrected_ppi_dhl &lt;- corrected_ppi_dhl filtered_corrected_ppi_dhl$data@data &lt;- as.data.frame(apply(filtered_corrected_ppi_dhl$data@data, 2, clip, bounds = c(0.05, 0.99))) 2.7 Distance to radar To assess the quality of the range-bias correction, it is also useful to calculate the distance to the radar from a given PPI pixel. Ideally, the range-bias correction would strongly reduce the effect of distance to the radar for measured densities of birds, but we still have to see if that is the case indeed. By including the distance to the radar in the PPIs, we can also include it in our modelling efforts later on. source(&quot;R/calculate_distance_to_radar.R&quot;) corrected_ppi_hrw &lt;- calculate_distance_to_radar(corrected_ppi_hrw) corrected_ppi_dhl &lt;- calculate_distance_to_radar(corrected_ppi_dhl) saveRDS(corrected_ppi_hrw, file = &quot;data/processed/corrected_ppi_hrw.RDS&quot;) saveRDS(corrected_ppi_dhl, file = &quot;data/processed/corrected_ppi_dhl.RDS&quot;) 2.7.1 Range-corrected PPI of Herwijnen radar mapview(filtered_corrected_ppi_hrw$data, alpha.regions = 0.6, col.regions = inferno, maxpixels=2000000, na.color = &quot;#00000000&quot;, map.types = c(&quot;CartoDB.Positron&quot;, &quot;CartoDB.DarkMatter&quot;, &quot;Esri.WorldImagery&quot;), layer.name = colnames(filtered_corrected_ppi_hrw$data@data)) 2.7.2 Range-corrected PPI of Den Helder radar mapview(filtered_corrected_ppi_dhl$data, alpha.regions = 0.6, col.regions = inferno, maxpixels=2000000, na.color = &quot;#00000000&quot;, map.types = c(&quot;CartoDB.Positron&quot;, &quot;CartoDB.DarkMatter&quot;, &quot;Esri.WorldImagery&quot;), layer.name = colnames(filtered_corrected_ppi_dhl$data@data)) 2.8 Preprocess additional scans Now that the processing steps have been explained in detail, we can now process the additional scans in our dataset in a similar fashion. For that we will focus on all scans from 22:00 CET until 01:00 CET, which corresponds with 23:00 until 02:00 in local Amsterdam time, as that should ‘cover’ most of the fireworks disturbance that occurs (based on the plots in Selecting firework take-off moment). source(&quot;R/preprocess_radar_data.R&quot;) hrw_pvols &lt;- Sys.glob(file.path(&quot;data/raw/pvol/fireworks-2017-2018&quot;, &quot;*NL62*&quot;)) dhl_pvols &lt;- Sys.glob(file.path(&quot;data/raw/pvol/fireworks-2017-2018&quot;, &quot;*NL61*&quot;)) dynamic_groundclutter_hrw &lt;- readRDS(&quot;data/processed/clutter_dynamic_hrw_avg.RDS&quot;) static_groundclutter_hrw &lt;- readRDS(&quot;data/processed/clutter_static_hrw_avg.RDS&quot;) dynamic_groundclutter_dhl &lt;- readRDS(&quot;data/processed/clutter_dynamic_dhl_avg.RDS&quot;) static_groundclutter_dhl &lt;- readRDS(&quot;data/processed/clutter_static_dhl_avg.RDS&quot;) for (pvol in hrw_pvols) { preprocess_radar_data(pvol_path = pvol, ei_rays = ei_rays_hrw, pvol_dynamic_groundclutter = dynamic_groundclutter_hrw, pvol_static_groundclutter = static_groundclutter_hrw) } for (pvol in dhl_pvols) { preprocess_radar_data(pvol_path = pvol, ei_rays = ei_rays_dhl, pvol_dynamic_groundclutter = dynamic_groundclutter_dhl, pvol_static_groundclutter = static_groundclutter_dhl, azim_limits = c(90, 200)) } References "],
["03.Annotate-land-use.html", "3 Annotating land use 3.1 Setting up the annotation environment 3.2 Converting the land use map 3.3 Adding land use classifications to the PPIs 3.4 Classify land use types in Urban vs. Rural 3.5 Calculate distance to nearest urban area 3.6 Add population density 3.7 Testing", " 3 Annotating land use In this study we aim to calculate ‘representative’ radar cross sections for birds aloft, based on the take-off habitat, which is probably a good indicator for the bird species/species groups measured by the radar. In this notebook we will classify land use and calculate the distance to the nearest urbanised areas for each of the PPI ‘pixels’. The land use is based on the CORINE Land Cover dataset and specifically the 2018 version (CLC2018), which should be most relevant for the 2017-2018 fireworks event. 3.1 Setting up the annotation environment library(raster) library(sf) library(stars) library(dplyr) library(ggplot2) library(ggpubr) library(gridExtra) library(viridis) library(mapview) 3.2 Converting the land use map To start, we need to convert the land use map to the same 1) resolution, and 2) extent of the radar PPIs as we can then simply ‘overlay’ both rasters on top of each other and do calculations. We load the PPIs and extract the CRS information contained in the proj4 strings. ppi_hrw &lt;- readRDS(&quot;data/processed/corrected_ppi_hrw.RDS&quot;) ppi_dhl &lt;- readRDS(&quot;data/processed/corrected_ppi_dhl.RDS&quot;) ppi_proj4_hrw &lt;- ppi_hrw$data@proj4string ppi_proj4_dhl &lt;- ppi_dhl$data@proj4string And we load and prepare the land use map it’s all about. To aid the classification process, we also load the land use classes contained in the entire CLC2018 dataset, otherwise the classes will remain anonymous numbers. landuse &lt;- raster(&quot;data/raw/landuse/clc2018_clc2018_v2018_20_raster100m/CLC2018_CLC2018_V2018_20.tif&quot;) landuse_classes &lt;- read.csv(&quot;data/raw/landuse/clc2018_clc2018_v2018_20_raster100m/Legend/CLC2018_CLC2018_V2018_20_QGIS.txt&quot;, col.names = c(&quot;landuse_id&quot;, &quot;r&quot;, &quot;g&quot;, &quot;b&quot;, &quot;x&quot;, &quot;landuse_class&quot;))[, c(&quot;landuse_id&quot;, &quot;landuse_class&quot;)] 3.2.1 Cropping the land use map As the CLC2018 dataset is so large it does not fit in memory at all in the steps below, so we have to crop the raster dataset for further processing. Even then, it still requires a beefy computer to process these files. First we calculate a bounding box for the landuse raster based on the bounding boxes of the radar data. padding &lt;- 25000 # Padding in m to make sure we crop out of the land use map with a wide margin to compensate for edge-effects later bbox_meters &lt;- abs(ppi_dhl$data@bbox[[1]]) + padding # Assuming the PPI range of DHL and HRW are the same bbox_hrw &lt;- st_bbox(c(xmin = -bbox_meters, ymin = -bbox_meters, xmax = bbox_meters, ymax = bbox_meters), crs = ppi_proj4_hrw) bbox_dhl &lt;- st_bbox(c(xmin = -bbox_meters, ymin = -bbox_meters, xmax = bbox_meters, ymax = bbox_meters), crs = ppi_proj4_dhl) bbox_hrw %&gt;% st_as_sfc() %&gt;% st_transform(crs(landuse)) %&gt;% st_bbox -&gt; bbox_landuse_hrw bbox_dhl %&gt;% st_as_sfc() %&gt;% st_transform(crs(landuse)) %&gt;% st_bbox -&gt; bbox_landuse_dhl We can now crop and plot the land use maps centered on the radar sites, with a 2.510^{4} meter padding surrounding the extent of the radar data. ext_hrw &lt;- extent(c(bbox_landuse_hrw[1], bbox_landuse_hrw[3], bbox_landuse_hrw[2], bbox_landuse_hrw[4])) ext_dhl &lt;- extent(c(bbox_landuse_dhl[1], bbox_landuse_dhl[3], bbox_landuse_dhl[2], bbox_landuse_dhl[4])) landuse_crop_hrw &lt;- crop(landuse, ext_hrw) landuse_crop_dhl &lt;- crop(landuse, ext_dhl) And plot the result: par(pty = &quot;s&quot;, mfrow = c(1, 2)) image(landuse_crop_hrw, main = &quot;Herwijnen&quot;) image(landuse_crop_dhl, main = &quot;Den Helder&quot;) Apparantly large swathes of the North Sea are set to NaN, so we better convert those to ‘Sea and ocean’ as well. sea_id &lt;- match(&#39;Sea and ocean&#39;, landuse_classes$landuse_class) landuse_crop_hrw[is.na(landuse_crop_hrw)] &lt;- landuse_classes[sea_id, &quot;landuse_id&quot;] landuse_crop_dhl[is.na(landuse_crop_dhl)] &lt;- landuse_classes[sea_id, &quot;landuse_id&quot;] par(pty = &quot;s&quot;, mfrow = c(1, 2)) image(landuse_crop_hrw, main = &quot;Herwijnen&quot;) image(landuse_crop_dhl, main = &quot;Den Helder&quot;) 3.2.2 Reprojecting the land use map Now that the land use map is cropped, we can start the reprojecting to the CRS of the radar PPI. As we’re dealing with categorical data, we set method = &quot;ngb&quot; to use nearest neighbour interpolation. landuse_hrw_reprojected &lt;- projectRaster(landuse_crop_hrw, crs = ppi_proj4_hrw, method = &quot;ngb&quot;) landuse_dhl_reprojected &lt;- projectRaster(landuse_crop_dhl, crs = ppi_proj4_dhl, method = &quot;ngb&quot;) levels(landuse_hrw_reprojected) &lt;- levels(landuse_crop_hrw) levels(landuse_dhl_reprojected) &lt;- levels(landuse_crop_dhl) If the reprojection went successful, the CRS of the reprojected land use map and the radar PPI should be the same. compareCRS(ppi_hrw$data@proj4string, landuse_hrw_reprojected@crs) compareCRS(ppi_dhl$data@proj4string, landuse_dhl_reprojected@crs) ## [1] TRUE ## [1] TRUE Apparently that is the case. 3.2.3 Resampling the land use map to a lower resolution The cellsize of the PPIs is 500, 500x500, 500 meters, but the land use map is much more finely detailed (~100x100m), so we need to resample the latter to derive a land use map at a 500, 500x500, 500 meter resolution as well. Simple nearest neighbour resampling was tested, but resulted in large parts of fairly small water bodies and especially the rivers ‘disappearing’ from the map, whereas these represent important habitats for birds to forage and roost. So instead, majority resampling, tweaked to retain more of the aforementioned water features was used to resize the land use raster to an appropriate resolution. The tweak constituted of setting the values of water courses and water bodies to the maximum value (total coverage of the assessed window) if half or more of the assessed window contained pixels classified as water courses or water bodies. The quality of this resampling was assessed visually. majority_resampling &lt;- function(raster, reference_raster, overwrite = FALSE) { values &lt;- c(sort(unique(getValues(raster)))) # classes: multidimensional logical array for the classes contained within the land use map classes &lt;- layerize(raster, filename = paste(&quot;data/processed/landuse/layerize/&quot;, substitute(raster), sep = &quot;&quot;), format = &quot;raster&quot;, bylayer = TRUE, classes = values, overwrite = overwrite) # factor: nr of cells in both horizontal and vertical direction to aggregate factor &lt;- round(dim(raster)[1:2] / dim(reference_raster)[1:2]) # agg: aggregated version of classes (aggregation factor defined by factor) containing max values per class, so 1 if a class is present agg &lt;- aggregate(classes, factor, na.rm = TRUE, fun = max) # x: resampled agg, now roughly containing land coverage percentages. Method must be bilinear, otherwise arbitrary choices keep being made. x &lt;- resample(agg, reference_raster) # Tweak the importance of water courses and bodies water_courses_id &lt;- match(511, values) water_bodies_id &lt;- match(512, values) x[[water_courses_id]][x[[water_courses_id]] &gt;= 0.5] &lt;- 1.1 x[[water_bodies_id]][x[[water_bodies_id]] &gt;= 0.5] &lt;- 1.1 # Flatten x in y y &lt;- which.max(x) # Reclassify back to original values values &lt;- data.frame(seq(1, length(values)), values) colnames(values) &lt;- c(&quot;is&quot;, &quot;becomes&quot;) y &lt;- reclassify(y, values) return(y) } landuse_hrw &lt;- majority_resampling(landuse_hrw_reprojected, as(ppi_hrw$data, &quot;RasterLayer&quot;), overwrite = TRUE) landuse_dhl &lt;- majority_resampling(landuse_dhl_reprojected, as(ppi_dhl$data, &quot;RasterLayer&quot;), overwrite = TRUE) writeRaster(landuse_hrw, &quot;data/processed/landuse/landuse_hrw_500m.tif&quot;, overwrite = TRUE) writeRaster(landuse_dhl, &quot;data/processed/landuse/landuse_dhl_500m.tif&quot;, overwrite = TRUE) By now the resampled land use raster should be very similar to the PPI raster, with the exception of — of course — the values contained within. compareRaster(landuse_hrw, as(ppi_hrw$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) compareRaster(landuse_dhl, as(ppi_dhl$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) ## [1] TRUE ## [1] TRUE Ok, let’s save a copy of what we have so far. saveRDS(landuse_hrw, &quot;data/processed/landuse/landuse_hrw.RDS&quot;) saveRDS(landuse_dhl, &quot;data/processed/landuse/landuse_dhl.RDS&quot;) 3.3 Adding land use classifications to the PPIs With the land use rasters overlapping exactly with the PPIs, we can simply extract the values of the resampled land use rasters and add these as additional parameters to the PPIs. Besides the code used, we will also add a description of the codes. landuse_hrw &lt;- readRDS(&quot;data/processed/landuse/landuse_hrw.RDS&quot;) landuse_dhl &lt;- readRDS(&quot;data/processed/landuse/landuse_dhl.RDS&quot;) values_hrw &lt;- as.data.frame(landuse_hrw@data@values) values_dhl &lt;- as.data.frame(landuse_dhl@data@values) ppi_hrw$data$landuse &lt;- as.numeric(unlist(values_hrw)) ppi_dhl$data$landuse &lt;- as.numeric(unlist(values_dhl)) ppi_hrw$data@data &lt;- ppi_hrw$data@data %&gt;% left_join(landuse_classes, by = c(&quot;landuse&quot; = &quot;landuse_id&quot;)) ppi_hrw$data$ID &lt;- NULL ppi_dhl$data@data &lt;- ppi_dhl$data@data %&gt;% left_join(landuse_classes, by = c(&quot;landuse&quot; = &quot;landuse_id&quot;)) ppi_dhl$data$ID &lt;- NULL 3.4 Classify land use types in Urban vs. Rural As we are interested in the effect urbanization has on the take-off decision of birds during the fireworks event, it is useful to categorise the land use types we have found so far as either ‘urban’ or ‘rural’ as well. urban_hrw &lt;- ppi_hrw$data@data$landuse &lt; 200 ppi_hrw$data$type &lt;- rep(&quot;rural&quot;, nrow(ppi_hrw$data)) ppi_hrw$data$type[urban_hrw] &lt;- &quot;urban&quot; ppi_hrw$data$type &lt;- as.factor(ppi_hrw$data$type) urban_dhl &lt;- ppi_dhl$data@data$landuse &lt; 200 ppi_dhl$data$type &lt;- rep(&quot;rural&quot;, nrow(ppi_dhl$data)) ppi_dhl$data$type[urban_dhl] &lt;- &quot;urban&quot; ppi_dhl$data$type &lt;- as.factor(ppi_dhl$data$type) 3.5 Calculate distance to nearest urban area For every cell on the raster that is not a cell we have just classified as ‘urban’ we will calculate the distance (in meters) to the nearest cell classified as ‘urban’. urban_hrw &lt;- ppi_hrw$data[, , &quot;type&quot;, drop = FALSE] urban_hrw$type[urban_hrw$type == &quot;rural&quot;] &lt;- NaN distance_to_urban_hrw &lt;- distance(as(urban_hrw, &#39;RasterLayer&#39;)) urban_dhl &lt;- ppi_dhl$data[, , &quot;type&quot;, drop = FALSE] urban_dhl$type[urban_dhl$type == &quot;rural&quot;] &lt;- NaN distance_to_urban_dhl &lt;- distance(as(urban_dhl, &#39;RasterLayer&#39;)) writeRaster(distance_to_urban_hrw, &quot;data/processed/landuse/dist_urban_hrw_500m.tif&quot;, overwrite = TRUE) writeRaster(distance_to_urban_dhl, &quot;data/processed/landuse/dist_urban_dhl_500m.tif&quot;, overwrite = TRUE) And we add these values to the PPIs again. values_dist_urban_hrw &lt;- as.data.frame(distance_to_urban_hrw@data@values) values_dist_urban_dhl &lt;- as.data.frame(distance_to_urban_dhl@data@values) ppi_hrw$data$dist_urban &lt;- as.numeric(unlist(values_dist_urban_hrw)) ppi_dhl$data$dist_urban &lt;- as.numeric(unlist(values_dist_urban_dhl)) 3.6 Add population density cbs_maps &lt;- st_read(&quot;data/raw/population-density/2019-CBS_VK500_2018_v1/CBS_VK500_2018_v1.shp&quot;) ## Reading layer `CBS_VK500_2018_v1&#39; from data source `/mnt/volume_ams3_01/raw/population-density/2019-CBS_VK500_2018_v1/CBS_VK500_2018_v1.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 151108 features and 31 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 13000 ymin: 306500 xmax: 278500 ymax: 619500 ## epsg (SRID): NA ## proj4string: +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs cbs_hrw &lt;- st_transform(cbs_maps, ppi_hrw$data@proj4string) cbs_dhl &lt;- st_transform(cbs_maps, ppi_dhl$data@proj4string) # Rasterize pop_density_rasterized_hrw &lt;- st_rasterize(cbs_hrw[&quot;INWONER&quot;], template = st_as_stars(st_bbox(ppi_hrw$data), dx = ppi_hrw$data@grid@cellsize[1], dy = ppi_hrw$data@grid@cellsize[2], values = NA_real_)) pop_density_rasterized_dhl &lt;- st_rasterize(cbs_dhl[&quot;INWONER&quot;], template = st_as_stars(st_bbox(ppi_dhl$data), dx = ppi_dhl$data@grid@cellsize[1], dy = ppi_dhl$data@grid@cellsize[2], values = NA_real_)) compareRaster(as(pop_density_rasterized_hrw, &quot;Raster&quot;), as(ppi_hrw$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) compareRaster(as(pop_density_rasterized_dhl, &quot;Raster&quot;), as(ppi_dhl$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) ## [1] TRUE ## [1] TRUE We can now calculate the total population in an area within ~2.5km around the center point. weights &lt;- matrix(1, nrow = 11, ncol = 11) pop_density_rasterized_hrw[pop_density_rasterized_hrw &lt; 0] &lt;- 0 pop_density_rasterized_dhl[pop_density_rasterized_dhl &lt; 0] &lt;- 0 pop_hrw &lt;- focal(as(pop_density_rasterized_hrw, &quot;Raster&quot;), w = weights, fun = sum, pad = TRUE, padValue = 0) pop_dhl &lt;- focal(as(pop_density_rasterized_dhl, &quot;Raster&quot;), w = weights, fun = sum, pad = TRUE, padValue = 0) And add it to the PPIs. values_pop_hrw &lt;- as.data.frame(pop_hrw@data@values) values_pop_dhl &lt;- as.data.frame(pop_dhl@data@values) ppi_hrw$data$pop &lt;- as.numeric(unlist(values_pop_hrw)) ppi_dhl$data$pop &lt;- as.numeric(unlist(values_pop_dhl)) 3.7 Testing Let’s make a few plots to see if what we have now gathered as additional information makes any sense 3.7.1 Plotting total VIR per land use type data_hrw &lt;- ppi_hrw$data@data %&gt;% filter(landuse_class != &quot;Land principally occupied by agriculture with significant areas of natural vegetation&quot; &amp; landuse_class != &quot;Sea and ocean&quot;) %&gt;% group_by(landuse_class) %&gt;% add_count() %&gt;% mutate(total_landuse_class = sum(VIR), total_prop_landuse_class = sum(VIR) / n) data_dhl &lt;- ppi_dhl$data@data %&gt;% filter(landuse_class != &quot;Land principally occupied by agriculture with significant areas of natural vegetation&quot; &amp; landuse_class != &quot;Sea and ocean&quot;) %&gt;% group_by(landuse_class) %&gt;% add_count() %&gt;% mutate(total_landuse_class = sum(VIR), total_prop_landuse_class = sum(VIR) / n) ggplot(data_hrw, aes(landuse_class, total_prop_landuse_class, fill = type)) + geom_col() + coord_flip() + labs(title = &quot;Herwijnen&quot;) ggplot(data_dhl, aes(landuse_class, total_prop_landuse_class, fill = type)) + geom_col() + coord_flip() + labs(title = &quot;Den Helder&quot;) 3.7.2 Plotting a distance to urban areas effect for VIR ggplot(ppi_dhl$data@data, aes(x = dist_urban, y = VIR, colour = landuse_class)) + geom_point(alpha = 0.5) + ylim(c(0, 500000)) + theme(legend.position = &quot;none&quot;) ggplot(ppi_hrw$data@data, aes(x = dist_urban, y = VIR, colour = landuse_class)) + geom_point(alpha = 0.5) + ylim(c(0, 500000)) + theme(legend.position = &quot;none&quot;) That seems alright, so we can save the PPIS we have now annotated. saveRDS(ppi_hrw, file = &quot;data/processed/corrected_ppi_hrw_lu.RDS&quot;) saveRDS(ppi_dhl, file = &quot;data/processed/corrected_ppi_dhl_lu.RDS&quot;) 3.7.3 Plotting it all on an interactive map 3.7.3.1 Interactive map of Herwijnen mapview(ppi_hrw$data[, , c(&quot;pop&quot;, &quot;dist_urban&quot;)], alpha.regions = 0.6, col.regions = inferno, maxpixels=2000000, na.color = &quot;#00000000&quot;, map.types = c(&quot;CartoDB.Positron&quot;, &quot;CartoDB.DarkMatter&quot;, &quot;Esri.WorldImagery&quot;), layer.name = c(&quot;pop&quot;, &quot;dist_urban&quot;)) 3.7.3.2 Interactive map of Den Helder mapview(ppi_dhl$data[, , c(&quot;pop&quot;, &quot;dist_urban&quot;)], alpha.regions = 0.6, col.regions = inferno, maxpixels=2000000, na.color = &quot;#00000000&quot;, map.types = c(&quot;CartoDB.Positron&quot;, &quot;CartoDB.DarkMatter&quot;, &quot;Esri.WorldImagery&quot;), layer.name = c(&quot;pop&quot;, &quot;dist_urban&quot;)) "],
["04.Annotate-count-areas.html", "4 Annotating count areas 4.1 Setting up the annotation environment 4.2 Annotate PPIs with waterbird area codes 4.3 Annotate PPIs with point-transect-counts", " 4 Annotating count areas We have data for the following counts provided by Sovon: Waterbird counts with a shapefile containing the surveyed areas and an xlsx file with the count results. Both can be linked using the GEBIEDID contained in both datasets. PTT counts, or point transect counts, contained within an xlsx file with the routes and all bird observations at an \\((X, Y)\\) location. To make processing efficient, we will ‘annotate’ the PPIs with the corresponding area codes for the waterbird counts and some identifier for the PTT counts. Doing so, we can later on calculate relevant count-based parameters (e.g. numbers of birds, average mass, etc.) and ‘join’ these by the corresponding identifiers. 4.1 Setting up the annotation environment library(bioRad) library(sf) library(stars) library(raster) library(dplyr) library(tidyr) library(readr) library(stringr) library(readxl) library(ggplot2) library(viridis) library(fasterize) ppi_hrw &lt;- readRDS(&quot;data/processed/corrected_ppi_hrw_lu.RDS&quot;) ppi_dhl &lt;- readRDS(&quot;data/processed/corrected_ppi_dhl_lu.RDS&quot;) 4.2 Annotate PPIs with waterbird area codes We rename the veriables retained in the shapefile to English and add a numerical wb_area_id which we can use to link the information retained in the shapefiles with the rasterized waterbird areas. All shapefiles are transformed to the CRS of the PPIs. wb_areas &lt;- st_read(&quot;data/raw/sovon/wavo_telgebieden.shp&quot;) %&gt;% rename(wb_area_nr = GEBIEDNR, wb_area_ha = OPPHA, xcoor = XCOOR, ycoor = YCOOR) ## Reading layer `wavo_telgebieden&#39; from data source `/mnt/volume_ams3_01/raw/sovon/wavo_telgebieden.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 4131 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 13551.48 ymin: 307546.8 xmax: 278027 ymax: 622790 ## epsg (SRID): NA ## proj4string: +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +no_defs wb_areas$wb_area_id &lt;- seq(1, length(wb_areas$wb_area_nr)) wb_areas_hrw &lt;- st_transform(wb_areas, ppi_hrw$data@proj4string) wb_areas_dhl &lt;- st_transform(wb_areas, ppi_dhl$data@proj4string) We rasterize specifically the newly created wb_area_id (as this is a numerical and not categorical value like wb_area_nr) following the ‘template’ of the existing PPIs. tpl_hrw &lt;- st_as_stars(st_bbox(ppi_hrw$data), dx = ppi_hrw$data@grid@cellsize[1], dy = ppi_hrw$data@grid@cellsize[2], values = NA_real_) tpl_dhl &lt;- st_as_stars(st_bbox(ppi_dhl$data), dx = ppi_dhl$data@grid@cellsize[1], dy = ppi_dhl$data@grid@cellsize[2], values = NA_real_) wb_areas_rasterized_hrw &lt;- st_rasterize(wb_areas_hrw[&quot;wb_area_id&quot;], template = tpl_hrw) wb_areas_rasterized_dhl &lt;- st_rasterize(wb_areas_dhl[&quot;wb_area_id&quot;], template = tpl_dhl) Let’s see how that’s gone so far. par(pty = &quot;s&quot;, mfrow = c(1, 2)) plot(wb_areas_rasterized_hrw, main = &quot;Herwijnen: wb_area_id&quot;) plot(wb_areas_rasterized_dhl, main = &quot;Den Helder: wb_area_id&quot;) Visually that seems to have gone well, now let’s make sure the rasterized waterbird areas share the same features as the PPI ‘rasters’. compareRaster(as(wb_areas_rasterized_hrw, &quot;Raster&quot;), as(ppi_hrw$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) compareRaster(as(wb_areas_rasterized_dhl, &quot;Raster&quot;), as(ppi_dhl$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) ## [1] TRUE ## [1] TRUE Twice a TRUE, so the rasters are identical (except for the values), so we can merge the datasets using a join on the wb_area_id. # Add the wb_area_id to the PPIs ppi_hrw$data$wb_area_id &lt;- unlist(as.data.frame(as(wb_areas_rasterized_hrw, &quot;Raster&quot;))) ppi_dhl$data$wb_area_id &lt;- unlist(as.data.frame(as(wb_areas_rasterized_dhl, &quot;Raster&quot;))) # Join the additional contents of the shapefiles ppi_hrw$data@data %&gt;% left_join(dplyr::select(as.data.frame(wb_areas_hrw), wb_area_id, wb_area_nr, wb_area_ha), by = c(&quot;wb_area_id&quot; = &quot;wb_area_id&quot;)) -&gt; ppi_hrw$data@data ppi_hrw$data$geometry &lt;- NULL ppi_dhl$data@data %&gt;% left_join(dplyr::select(as.data.frame(wb_areas_dhl), wb_area_id, wb_area_nr, wb_area_ha), by = c(&quot;wb_area_id&quot; = &quot;wb_area_id&quot;)) -&gt; ppi_dhl$data@data ppi_dhl$data$geometry &lt;- NULL Let’s verify if that occurred as planned. plot(ppi_hrw, param = &quot;wb_area_id&quot;, zlim = c(min(ppi_hrw$data@data$wb_area_id, na.rm = TRUE), max(ppi_hrw$data@data$wb_area_id, na.rm = TRUE))) plot(ppi_dhl, param = &quot;wb_area_id&quot;, zlim = c(min(ppi_dhl$data@data$wb_area_id, na.rm = TRUE), max(ppi_dhl$data@data$wb_area_id, na.rm = TRUE))) This looks very comparable to the plots of the rasterized scans above and wb_area_id shows similar areas in similar colors, so this worked fine. 4.3 Annotate PPIs with point-transect-counts The PTT point transect counts are organized by routes, which consist of a few points. We can follow the same approach as above with the waterbird counts, by creating coverage shapes (like the shapefile features for the waterbird areas) for each of the routes. Using the convex hull of the points within a route seems like a good starting point to convert these points to areas. However, in that case it would appear as if birds are only counted when looking ‘inwards’ to this shape. By buffering these convex hulls with a radius of the average distance between successive points, a more representative coverage area can be generated. 4.3.1 Loading PTT points We load the PTT data directly from the xlsx file provided by Sovon and rename the variables to English. ptt &lt;- read_excel(&quot;data/raw/sovon/tel_dec_jan_1718.xlsx&quot;, sheet = &quot;ptt&quot;) %&gt;% rename(count_id = tellingid, route = route, count_point = telpunt, season = seizoen, year = teljaar, month = maand, day = dag, species = soort, number = aantal) head(ptt, 10) count_id route count_point season year month day euring species number xcoor ycoor 80917 4 1 2017 2017 12 23 720 Aalscholver 2 246342 520763 80917 4 1 2017 2017 12 23 5920 Zilvermeeuw 18 246342 520763 80917 4 1 2017 2017 12 23 6700 Houtduif 1 246342 520763 80917 4 1 2017 2017 12 23 11870 Merel 4 246342 520763 80917 4 1 2017 2017 12 23 15630 Roek 24 246342 520763 80917 4 2 2017 2017 12 23 6700 Houtduif 1 246357 522178 80917 4 2 2017 2017 12 23 11870 Merel 1 246357 522178 80917 4 2 2017 2017 12 23 15600 Kauw 6 246357 522178 80917 4 2 2017 2017 12 23 15630 Roek 78 246357 522178 80917 4 3 2017 2017 12 23 14620 Pimpelmees 2 246692 523139 As we’re not interested in all the data here, we will load a subset of the columns, specifically all unique combinations of routes and points, which will yield the corresponding xcoor and ycoor coordinates for each count_point within a route. ptt %&gt;% dplyr::select(route, count_point, xcoor, ycoor) %&gt;% group_by(route, count_point) %&gt;% slice(1) -&gt; ptt head(ptt, 10) route count_point xcoor ycoor 4 1 246342 520763 4 2 246357 522178 4 3 246692 523139 4 4 248122 522563 4 5 248249 521818 4 6 248649 523073 4 7 249142 523614 4 8 250073 523534 4 9 252142 523524 4 10 253056 523458 4.3.2 Calculate interpoint distances For each of the routes within the PTT dataset, we will calculate the average distance between the subsequent points, to buffer our convex hull by this value. ptt %&gt;% group_by(route) %&gt;% mutate(xcoor2 = c(xcoor[-1], 0), ycoor2 = c(ycoor[-1], 0)) %&gt;% rowwise() %&gt;% mutate(interpoint_distance = pointDistance(cbind(xcoor, ycoor), cbind(xcoor2, ycoor2), lonlat = FALSE)) %&gt;% ungroup() %&gt;% filter(xcoor2 != 0) %&gt;% # Throw out last point from route where distance to next point is not relevant group_by(route) %&gt;% summarise(avg_interpoint_distance = mean(interpoint_distance)) -&gt; ptt_interpoint_distances ptt %&gt;% left_join(ptt_interpoint_distances, by = c(&quot;route&quot; = &quot;route&quot;)) -&gt; ptt head(ptt, 10) route count_point xcoor ycoor avg_interpoint_distance 4 1 246342 520763 1162.042 4 2 246357 522178 1162.042 4 3 246692 523139 1162.042 4 4 248122 522563 1162.042 4 5 248249 521818 1162.042 4 6 248649 523073 1162.042 4 7 249142 523614 1162.042 4 8 250073 523534 1162.042 4 9 252142 523524 1162.042 4 10 253056 523458 1162.042 We can now calculate the convex hulls of the points grouped by route. ptt %&gt;% st_as_sf(coords = c(&quot;xcoor&quot;, &quot;ycoor&quot;), crs = 28992) %&gt;% st_transform(crs = ppi_hrw$data@proj4string) %&gt;% group_by(route, avg_interpoint_distance) %&gt;% summarise() %&gt;% st_convex_hull() -&gt; ptt_convex_hulls_hrw ptt %&gt;% st_as_sf(coords = c(&quot;xcoor&quot;, &quot;ycoor&quot;), crs = 28992) %&gt;% # original CRS = EPSG:28992 (RD New) st_transform(crs = ppi_dhl$data@proj4string) %&gt;% group_by(route, avg_interpoint_distance) %&gt;% summarise() %&gt;% st_convex_hull() -&gt; ptt_convex_hulls_dhl plot(ptt_convex_hulls_hrw[1], main = &quot;PTT Routes Herwijnen: Route&quot;) plot(ptt_convex_hulls_hrw[2], main = &quot;PTT Routes Herwijnen: Avg interpoint dist.&quot;) plot(ptt_convex_hulls_dhl[1], main = &quot;PTT Routes Den Helder: Route&quot;) plot(ptt_convex_hulls_dhl[2], main = &quot;PTT Routes Den Helder: Avg interpoint dist.&quot;) As we have calculated the average distance between the points, we can now buffer the convex hulls by this value to attain more representative sizes of the covered areas. ptt_convex_hulls_hrw %&gt;% st_buffer(dist = as.double(ptt_convex_hulls_hrw$avg_interpoint_distance)) -&gt; ptt_convex_hulls_hrw ptt_convex_hulls_dhl %&gt;% st_buffer(dist = as.double(ptt_convex_hulls_dhl$avg_interpoint_distance)) -&gt; ptt_convex_hulls_dhl plot(ptt_convex_hulls_hrw[1], main = &quot;Buffered PTT Routes Herwijnen&quot;) plot(ptt_convex_hulls_dhl[1], main = &quot;Buffered PTT Routes Den Helder&quot;) Now that is taken care of, we can rasterize the polygons using the fasterize package. As there is overlap between the areas covered by the routes using the convex hulls and a raster can only contain a single value for every pixel, we need to resolve this overlap. In this case we will compare overlapping areas and pick those where the average distance between the points for that area is lowest. This biases towards counts that cover a smaller area, so probably resulting in more accurate estimates of birds around. ptt_hrw &lt;- raster(ppi_hrw$data) ptt_dhl &lt;- raster(ppi_dhl$data) ptt_hrw &lt;- fasterize(ptt_convex_hulls_hrw, ptt_hrw, field = &quot;route&quot;, by = &quot;avg_interpoint_distance&quot;) ptt_dhl &lt;- fasterize(ptt_convex_hulls_dhl, ptt_dhl, field = &quot;route&quot;, by = &quot;avg_interpoint_distance&quot;) ptt_hrw &lt;- suppressWarnings(stackApply(ptt_hrw, indices = rep(1, length(ptt_hrw)), fun = min, na.rm = TRUE)) ptt_dhl &lt;- suppressWarnings(stackApply(ptt_dhl, indices = rep(1, length(ptt_dhl)), fun = min, na.rm = TRUE)) plot(ptt_hrw, main = &quot;Rasterized PTT routes Herwijnen&quot;) plot(ptt_dhl, main = &quot;Rasterized PTT routes Den Helder&quot;) This approach to solving the issue of overlapping polygons introduces a possible problem here, where it will eventually result in larger numbers of birds (corresponding to a single route) being spread over a smaller area of land (after the overlap is removed from some polygons). However, I don’t really see an alternative solution to this problem, except by averaging the numbers of birds over the whole area covered by the PTT counts. This would result in much less flexibility later on when calculating relevant bird parameters, so for now we leave it as is. With the rasterization done, let’s compare the resultant raster and see if it is identical to the PPIs. compareRaster(as(ptt_hrw, &quot;Raster&quot;), as(ppi_hrw$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) compareRaster(as(ptt_dhl, &quot;Raster&quot;), as(ppi_dhl$data, &quot;RasterLayer&quot;), extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE, orig = TRUE) ## [1] TRUE ## [1] TRUE Two TRUEs, so that’s excellent. We can now add the ptt_route to the PPIs. ppi_hrw$data$ptt_route &lt;- unlist(as.data.frame(as(ptt_hrw, &quot;Raster&quot;))) ppi_dhl$data$ptt_route &lt;- unlist(as.data.frame(as(ptt_dhl, &quot;Raster&quot;))) Let’s verify once again if that occurred as planned. plot(ppi_hrw, param = &quot;ptt_route&quot;, zlim = c(min(ppi_hrw$data@data$ptt_route, na.rm = TRUE), max(ppi_hrw$data@data$ptt_route, na.rm = TRUE))) plot(ppi_dhl, param = &quot;ptt_route&quot;, zlim = c(min(ppi_dhl$data@data$ptt_route, na.rm = TRUE), max(ppi_dhl$data@data$ptt_route, na.rm = TRUE))) That seems fine, we can now save the PPIs, so we can start linking actual count data. saveRDS(ppi_hrw, file = &quot;data/processed/corrected-ppis-lu-sovon/corrected_ppi_hrw_lu_sovon.RDS&quot;) saveRDS(ppi_dhl, file = &quot;data/processed/corrected-ppis-lu-sovon/corrected_ppi_dhl_lu_sovon.RDS&quot;) "],
["05.Processing-count-results.html", "5 Processing count results 5.1 Setting up the processing environment 5.2 Loading the Sovon count data 5.3 Filtering/preprocessing species names 5.4 Linking life-history traits to species", " 5 Processing count results For now, we are interested in calculating the following parameters for the count results: The number of birds within every PPI pixel. The average mass of the birds within every PPI pixel. We can derive the total numbers of birds comparatively easily from the bird counts by Sovon, but to calculate the average mass of the birds we need to link a database of life-history traits. For the latter we first need to translate the vernacular (modern) names of bird species to the scientific ones, so we can link both. 5.1 Setting up the processing environment library(rgbif) library(stringr) library(readxl) library(dplyr) library(tidyr) library(readr) library(kableExtra) ## ## Attaching package: &#39;kableExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows 5.2 Loading the Sovon count data The count data is spread over a few sheets in an xlsx file, which we load here. For clarity, we rename all the columns to English and we filter out all counts (i.e. areas) where birds are not positively identified to species level. Although it would be possible to ‘fill’ these uncertain counts based on proportions, determining how to do that is not necessary for our purposes. Instead, we will just remove these counts altogether. Finally, subspecies identifiers for these species are removed, as we assume there is no variation between subspecies to negatively affect our results, nor does the database of life-history traits contain parameters for subspecies. sovon_data &lt;- &quot;data/raw/sovon/tel_dec_jan_1718.xlsx&quot; data &lt;- data.frame() sheets &lt;- excel_sheets(sovon_data) sheets &lt;- sheets[-c(1, 5)] # Sheet 1 and 5 contain PTT and roost counts respectively, so we ignore these for now, as they have to be processed differently # Explicit column types to suppress warnings thrown because of lacking euring codes for records with no birds coltypes &lt;- c(&quot;numeric&quot;, &quot;text&quot;, &quot;numeric&quot;, &quot;numeric&quot;, &quot;numeric&quot;, &quot;numeric&quot;, &quot;numeric&quot;, &quot;numeric&quot;, &quot;text&quot;, &quot;numeric&quot;, &quot;numeric&quot;, &quot;numeric&quot;) for (i in seq_along(sheets)) { data &lt;- rbind(data, read_excel(sovon_data, sheet = sheets[i], col_types = coltypes)) } data %&gt;% drop_na() %&gt;% # A few rows somehow contain no birds or species &#39;geen vogels&#39; rename(count_id = TELLING_ID, area_nr = GEBIEDSCODE, year = JAAR, month = MAAND, day = DAG, start_time = BEGINTIJD, end_time = EINDTIJD, &quot;euring&quot; = &quot;EURING&quot;, species = SOORT, number = Aantal, xcoor = XCOOR, ycoor = YCOOR) %&gt;% group_by(area_nr) %&gt;% filter(!any(str_ends(species, &quot;spec.&quot;))) %&gt;% # Filter out all counts with unidentified birds filter(!any(length(str_subset(species, &quot; of &quot;)) &gt; 0)) %&gt;% # Filter out all counts with either/or totals filter(!any(str_starts(species, &quot;hybride&quot;))) %&gt;% # Filter out all counts with hybrids ungroup() %&gt;% rowwise() %&gt;% mutate(species = str_split(species, &quot;\\\\(&quot;)[[1]][1] %&gt;% str_trim()) -&gt; wb_data # And remove all subspecies identifications head(wb_data, 10) %&gt;% kable(format = &quot;html&quot;, col.names = colnames(wb_data)) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;400px&quot;) count_id area_nr year month day start_time end_time euring species number xcoor ycoor 1060908 BR1111 2017 12 19 1045 1108 1610 Grauwe Gans 280 127723 426233 1060908 BR1111 2017 12 19 1045 1108 1700 Nijlgans 2 127723 426233 1060909 BR1112 2017 12 19 1108 1126 1610 Grauwe Gans 76 125082 426701 1060909 BR1112 2017 12 19 1108 1126 1661 Grote Canadese Gans 50 125082 426701 1060909 BR1112 2017 12 19 1108 1126 1700 Nijlgans 22 125082 426701 1060906 BR1122 2017 12 19 1020 1037 1610 Grauwe Gans 250 125313 426061 1060906 BR1122 2017 12 19 1020 1037 1619 Soepgans 5 125313 426061 1060906 BR1122 2017 12 19 1020 1037 1661 Grote Canadese Gans 35 125313 426061 1060911 BR1130 2017 12 19 1145 1200 1610 Grauwe Gans 200 121962 426420 1060911 BR1130 2017 12 19 1145 1200 1661 Grote Canadese Gans 40 121962 426420 Following this logic, we can process the PTT counts similarly and see which species are contained in those. read_excel(sovon_data, sheet = 1) %&gt;% rename(count_id = tellingid, route = route, count_point = telpunt, season = seizoen, year = teljaar, month = maand, day = dag, euring = euring, species = soort, number = aantal, xcoor = xcoor, ycoor = ycoor) %&gt;% group_by(route, count_point) %&gt;% filter(!any(str_ends(species, &quot;spec.&quot;))) %&gt;% # Filter out all counts with unidentified birds filter(!any(length(str_subset(species, &quot; of &quot;)) &gt; 0)) %&gt;% # Filter out all counts with either/or totals filter(!any(str_starts(species, &quot;hybride&quot;))) %&gt;% # Filter out all counts with hybrids ungroup() %&gt;% rowwise() %&gt;% mutate(species = str_split(species, &quot;\\\\(&quot;)[[1]][1] %&gt;% str_trim()) -&gt; ptt_data # And remove all subspecies identifications-&gt; ptt_data head(ptt_data, 10) %&gt;% kable(format = &quot;html&quot;, col.names = colnames(ptt_data)) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;400px&quot;) count_id route count_point season year month day euring species number xcoor ycoor 80917 4 1 2017 2017 12 23 720 Aalscholver 2 246342 520763 80917 4 1 2017 2017 12 23 5920 Zilvermeeuw 18 246342 520763 80917 4 1 2017 2017 12 23 6700 Houtduif 1 246342 520763 80917 4 1 2017 2017 12 23 11870 Merel 4 246342 520763 80917 4 1 2017 2017 12 23 15630 Roek 24 246342 520763 80917 4 2 2017 2017 12 23 6700 Houtduif 1 246357 522178 80917 4 2 2017 2017 12 23 11870 Merel 1 246357 522178 80917 4 2 2017 2017 12 23 15600 Kauw 6 246357 522178 80917 4 2 2017 2017 12 23 15630 Roek 78 246357 522178 80917 4 3 2017 2017 12 23 14620 Pimpelmees 2 246692 523139 5.3 Filtering/preprocessing species names The following section is the result of an iterative process aimed at matching species in our count data with species in the database of life-history characteristics. Unfortunately, automatic tools only get us so far, a bit of tweaking has to be done by hand. To reduce manual corrections needed, only species to which &gt;1% of the birds belong in a single count have been corrected manually. In other words: if a species which cannot be matched always accounts for less than 1% of the total number of birds within a count, this species is discarded from the whole dataset. Besides the 1% criteria, both the waterbird and PTT counts contain some exotics (e.g. ‘Helmparelhoen’/Helmeted guineafowl) for which our life-history characteristics dataset does not contain any measurements anyways (there are others that we do have measurements of), some species that are very unlikely to ever take flight during NYE (e.g. ‘Kip’/Domesticated chicken) and some mammals for which the same applies. We will remove these from the dataset manually. exotics &lt;- c(&quot;Helmparelhoen&quot;, &quot;Kaapse Casarca&quot;, &quot;Manengans&quot;, &quot;Ringtaling&quot;, &quot;Buffelkopeend&quot;, &quot;Kokardezaagbek&quot;, &quot;Chileense Flamingo&quot;, &quot;Kaapse Taling&quot;, &quot;Bahamapijlstaart&quot;, &quot;Muskuseend&quot;, &quot;Zwarte Zwaan&quot;, &quot;Knobbelgans&quot;, &quot;Zwaangans&quot;) unlikely_flight_candidate &lt;- c(&quot;Kip&quot;) mammals &lt;- c(&quot;Damhert&quot;, &quot;Haas&quot;, &quot;Ree&quot;, &quot;Bever&quot;, &quot;Bruine Rat&quot;, &quot;Muskusrat&quot;, &quot;Mol&quot;, &quot;Vos&quot;, &quot;Kat&quot;, &quot;Otter&quot;, &quot;Grijze Zeehond&quot;, &quot;Konijn&quot;, &quot;Eekhoorn&quot;, &quot;Edelhert&quot;, &quot;Gewone Zeehond&quot;, &quot;Wild Zwijn&quot;, &quot;Steenmarter&quot;, &quot;Moeflon&quot;) input_error &lt;- c(&quot;Steltstrandloper&quot;) remove_species &lt;- c(exotics, unlikely_flight_candidate, mammals, input_error) ptt_data %&gt;% filter(!species %in% remove_species) -&gt; ptt_data wb_data %&gt;% filter(!species %in% remove_species) -&gt; wb_data With all these species removed or adjusted, we can create a species lookup table. We fetch the scientific names and corresponding GBIF species IDs from the Checklist Dutch Species Register, which is the GBIF dataset with key 4dd32523-a3a3-43b7-84df-4cda02f15cf7. We furthermore remove all unnecessary information, such as subspecies from the scientific names as well. unique_species &lt;- unique(c(wb_data$species, ptt_data$species)) build_species_lut &lt;- function(specieslist, datasetKey = NULL, higherTaxonKey = NULL) { # As this function can possibly return many different records, we pick the scientific name and GBIF ID (nubKey) that are the most # common in the returned results. This should most often result in an OK result of the name lookup function. Mode &lt;- function(x) { ux &lt;- unique(na.omit(x)) ux[which.max(tabulate(match(x, ux)))] } n &lt;- length(specieslist) species_lut &lt;- data.frame(lookupname = character(n), scientificname = character(n), gbif_key = numeric(n), stringsAsFactors = FALSE) for(i in seq_along(specieslist)) { gbif_data &lt;- tryCatch({ gbif &lt;- name_lookup(specieslist[i], datasetKey = datasetKey, higherTaxonKey = higherTaxonKey, return = &quot;data&quot;) list(paste(str_split(Mode(gbif$scientificName), pattern = &quot; &quot;)[[1]][1:2], collapse = &quot; &quot;), Mode(gbif$nubKey)) }, error = function(e) { list(&quot;&quot;, NaN) }) species_lut[i, ] &lt;- c(specieslist[i], gbif_data[1], as.numeric(as.character(gbif_data[2]))) } return(species_lut) } # The following query defines a `higherTaxonKey`, which is a way to filter for birds fairly easily. # Somehow this ID is not fully persistent, so in case the following returns only NaNs for gbif_keys, # check the Aves taxon in the Checklist Dutch Species Register species_lut &lt;- build_species_lut(unique_species, datasetKey = &quot;4dd32523-a3a3-43b7-84df-4cda02f15cf7&quot;, higherTaxonKey = 162425859) head(species_lut, 10) %&gt;% kable(format = &quot;html&quot;, col.names = colnames(species_lut)) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;400px&quot;) lookupname scientificname gbif_key Grauwe Gans Anser anser 2498036 Nijlgans Alopochen aegyptiaca 2498252 Grote Canadese Gans Branta canadensis 5232437 Soepgans Anser anser 9384117 Brandgans Branta leucopsis 5232464 Knobbelzwaan Cygnus olor 2498343 Kolgans Anser albifrons 2498017 Canadese Gans Branta hutchinsii 5232460 Toendrarietgans Anser serrirostris 9455781 Kleine Zwaan Cygnus bewickii 4409105 Finally, the lookup table also contains some scientific names which unfortunately will not match with the life-history characteristics dataset, so these too we will adjust manually. # Change to similar species which is in the LHT database species_lut[species_lut$lookupname == &quot;Toendrarietgans&quot;, &quot;scientificname&quot;] &lt;- &quot;Anser fabalis&quot; # Taiga Bean Goose species_lut[species_lut$lookupname == &quot;Kleine Canadese Gans&quot;, &quot;scientificname&quot;] &lt;- &quot;Branta leucopsis&quot; # Barnacle Goose species_lut[species_lut$lookupname == &quot;Kleine Barmsijs&quot;, &quot;scientificname&quot;] &lt;- &quot;Acanthis flammea&quot; # Redpoll species_lut[species_lut$lookupname == &quot;Pontische Meeuw&quot;, &quot;scientificname&quot;] &lt;- &quot;Larus argentatus&quot; # Herring Gull species_lut[species_lut$lookupname == &quot;Indische Gans&quot;, &quot;scientificname&quot;] &lt;- &quot;Anser albifrons&quot; # Greater White-fronted Goose species_lut[species_lut$lookupname == &quot;Canadese Gans&quot;, &quot;scientificname&quot;] &lt;- &quot;Branta canadensis&quot; # Canada Goose # Change scientific name for same species to match with the LHT database species_lut[species_lut$lookupname == &quot;Kleine Zwaan&quot;, &quot;scientificname&quot;] &lt;- &quot;Cygnus columbianus&quot; # Bewick&#39;s Swan species_lut[species_lut$lookupname == &quot;Kokmeeuw&quot;, &quot;scientificname&quot;] &lt;- &quot;Larus ridibundus&quot; # Black-headed Gull species_lut[species_lut$lookupname == &quot;Smient&quot;, &quot;scientificname&quot;] &lt;- &quot;Mareca penelope&quot; # Wigeon species_lut[species_lut$lookupname == &quot;Krakeend&quot;, &quot;scientificname&quot;] &lt;- &quot;Mareca strepera&quot; # Gadwall species_lut[species_lut$lookupname == &quot;Slobeend&quot;, &quot;scientificname&quot;] &lt;- &quot;Spatula clypeata&quot; # Northern Shoveler species_lut[species_lut$lookupname == &quot;Winterkoning&quot;, &quot;scientificname&quot;] &lt;- &quot;Troglodytes troglodytes&quot; # Wren species_lut[species_lut$lookupname == &quot;Grote Jager&quot;, &quot;scientificname&quot;] &lt;- &quot;Catharacta skua&quot; # Great Skua species_lut[species_lut$lookupname == &quot;Roodborsttapuit&quot;, &quot;scientificname&quot;] &lt;- &quot;Saxicola torquatus&quot; # Stonechat species_lut[species_lut$lookupname == &quot;Strandleeuwerik&quot;, &quot;scientificname&quot;] &lt;- &quot;Eremophila alpestris&quot; # Horned Lark 5.4 Linking life-history traits to species We use the Life-history characteristics of European birds-dataset (Storchová and Hořák 2018) to calculate the mean mass of all birds in a PPI pixel. This dataset is stored on Dryad and we can download it there. Unfortunately the rdryad package is severely out-of-date with the new Dryad API, so we cannot nicely automate this download yet. Anyways, the files should be downloaded manually and added to data/raw/life-history-characteristics/. We calculate the mean of the mass of both sexed and unsexed birds and assume they occur read_tsv(&quot;data/raw/life-history-characteristics/Life-history characteristics of European birds.txt&quot;, col_types = cols_only(&#39;Species&#39; = col_character(), &#39;WeightU_MEAN&#39; = col_double(), &#39;WeightM_MEAN&#39; = col_double(), &#39;WeightF_MEAN&#39; = col_double())) %&gt;% rowwise %&gt;% mutate(mean_weight = mean(c(WeightU_MEAN, WeightF_MEAN, WeightM_MEAN))) %&gt;% dplyr::select(Species, mean_weight) %&gt;% rename(species = Species) %&gt;% filter(!any(str_ends(species, &quot;ssp&quot;))) %&gt;% # Filter out birds not identified to species drop_na() -&gt; lhc lhc[lhc$species == &quot;Aquila nipalenis&quot;, &quot;species&quot;] &lt;- &quot;Aquila nipalensis&quot; # Small error in dataset -&gt; notified author head(lhc, 10) %&gt;% kable(format = &quot;html&quot;, col.names = colnames(lhc)) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;400px&quot;) species mean_weight Accipiter brevipes 221.5 Accipiter gentilis 931.5 Accipiter nisus 204.0 Aegypius monachus 9625.0 Aquila adalberti 3000.0 Aquila fasciata 1905.0 Aquila heliaca 3262.5 Aquila chrysaetos 4383.0 Aquila nipalensis 2723.0 Buteo buteo 806.5 Now we can try to link the names once again with what can be found in GBIF. unique_species_lhc &lt;- unique(lhc$species) lhc_species_lut &lt;- build_species_lut(unique_species_lhc, dataset = NULL) head(lhc_species_lut, 10) %&gt;% kable(format = &quot;html&quot;, col.names = colnames(lhc_species_lut)) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;400px&quot;) lookupname scientificname gbif_key Accipiter brevipes Accipiter brevipes 2480578 Accipiter gentilis Accipiter gentilis 2480589 Accipiter nisus Accipiter nisus 2480637 Aegypius monachus Aegypius monachus 5229165 Aquila adalberti Aquila adalberti 2480510 Aquila fasciata Aquila fasciata 5844449 Aquila heliaca Aquila heliaca 2480500 Aquila chrysaetos Aquila chrysaetos 2480506 Aquila nipalensis Aquila nipalensis 2480513 Buteo buteo Buteo buteo 2480537 With the GBIF IDs/keys in place for both the life-history characteristics, as well as the Sovon counts, we can now link the datasets together. First the waterbirds lhc %&gt;% left_join(lhc_species_lut, by = c(&quot;species&quot; = &quot;scientificname&quot;)) %&gt;% dplyr::select(species, mean_weight, gbif_key) -&gt; lhc wb_data %&gt;% left_join(species_lut, by = c(&quot;species&quot; = &quot;lookupname&quot;)) %&gt;% left_join(dplyr::select(lhc, mean_weight, gbif_key), by = c(&quot;gbif_key&quot; = &quot;gbif_key&quot;)) %&gt;% left_join(dplyr::select(lhc, mean_weight, species), by = c(&quot;scientificname&quot; = &quot;species&quot;)) %&gt;% dplyr::select(-c(mean_weight.x)) %&gt;% rename(mean_weight = mean_weight.y) -&gt; wb_data_lhc head(wb_data_lhc, 10) %&gt;% kable(format = &quot;html&quot;, col.names = colnames(wb_data_lhc)) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;400px&quot;) count_id area_nr year month day start_time end_time euring species number xcoor ycoor scientificname gbif_key mean_weight 1060908 BR1111 2017 12 19 1045 1108 1610 Grauwe Gans 280 127723 426233 Anser anser 2498036 3347 1060908 BR1111 2017 12 19 1045 1108 1700 Nijlgans 2 127723 426233 Alopochen aegyptiaca 2498252 2270 1060909 BR1112 2017 12 19 1108 1126 1610 Grauwe Gans 76 125082 426701 Anser anser 2498036 3347 1060909 BR1112 2017 12 19 1108 1126 1661 Grote Canadese Gans 50 125082 426701 Branta canadensis 5232437 4635 1060909 BR1112 2017 12 19 1108 1126 1700 Nijlgans 22 125082 426701 Alopochen aegyptiaca 2498252 2270 1060906 BR1122 2017 12 19 1020 1037 1610 Grauwe Gans 250 125313 426061 Anser anser 2498036 3347 1060906 BR1122 2017 12 19 1020 1037 1619 Soepgans 5 125313 426061 Anser anser 9384117 3347 1060906 BR1122 2017 12 19 1020 1037 1661 Grote Canadese Gans 35 125313 426061 Branta canadensis 5232437 4635 1060911 BR1130 2017 12 19 1145 1200 1610 Grauwe Gans 200 121962 426420 Anser anser 2498036 3347 1060911 BR1130 2017 12 19 1145 1200 1661 Grote Canadese Gans 40 121962 426420 Branta canadensis 5232437 4635 And then the PTT counts ptt_data %&gt;% left_join(species_lut, by = c(&quot;species&quot; = &quot;lookupname&quot;)) %&gt;% left_join(dplyr::select(lhc, mean_weight, gbif_key), by = c(&quot;gbif_key&quot; = &quot;gbif_key&quot;)) %&gt;% left_join(dplyr::select(lhc, mean_weight, species), by = c(&quot;scientificname&quot; = &quot;species&quot;)) %&gt;% dplyr::select(-c(mean_weight.x)) %&gt;% rename(mean_weight = mean_weight.y) -&gt; ptt_data_lhc head(ptt_data_lhc, 10) %&gt;% kable(format = &quot;html&quot;, col.names = colnames(ptt_data_lhc)) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;400px&quot;) count_id route count_point season year month day euring species number xcoor ycoor scientificname gbif_key mean_weight 80917 4 1 2017 2017 12 23 720 Aalscholver 2 246342 520763 Phalacrocorax carbo 2481890 2254.0 80917 4 1 2017 2017 12 23 5920 Zilvermeeuw 18 246342 520763 Larus argentatus 2481139 1054.0 80917 4 1 2017 2017 12 23 6700 Houtduif 1 246342 520763 Columba palumbus 2495455 496.5 80917 4 1 2017 2017 12 23 11870 Merel 4 246342 520763 Turdus merula 2490719 97.0 80917 4 1 2017 2017 12 23 15630 Roek 24 246342 520763 Corvus frugilegus 2482513 459.0 80917 4 2 2017 2017 12 23 6700 Houtduif 1 246357 522178 Columba palumbus 2495455 496.5 80917 4 2 2017 2017 12 23 11870 Merel 1 246357 522178 Turdus merula 2490719 97.0 80917 4 2 2017 2017 12 23 15600 Kauw 6 246357 522178 Corvus monedula 2482473 236.0 80917 4 2 2017 2017 12 23 15630 Roek 78 246357 522178 Corvus frugilegus 2482513 459.0 80917 4 3 2017 2017 12 23 14620 Pimpelmees 2 246692 523139 Cyanistes caeruleus 2487879 11.5 Now we can verify if our 1% criteria for species matching is met. We do this by calculating the proportions of birds belonging to a certain species out of the total numbers of birds counted within a count. This should result in an empty dataframe, which will stop the code chunk below from running if that is not the case. wb_data_lhc %&gt;% as.data.frame() %&gt;% group_by(count_id) %&gt;% mutate(total_birds_count = sum(number)) %&gt;% group_by(count_id, species) %&gt;% mutate(proportion_species = sum(number) / total_birds_count) %&gt;% ungroup() %&gt;% arrange(count_id) %&gt;% filter((is.na(mean_weight) &amp; (proportion_species &gt; 0.01))) -&gt; wb_data_lhc_verify stopifnot(nrow(wb_data_lhc_verify) == 0) rm(wb_data_lhc_verify) And once again, we can do the same for the PTT counts. ptt_data_lhc %&gt;% as.data.frame() %&gt;% group_by(count_id) %&gt;% mutate(total_birds_count = sum(number)) %&gt;% group_by(count_id, species) %&gt;% mutate(proportion_species = sum(number) / total_birds_count) %&gt;% ungroup() %&gt;% arrange(count_id) %&gt;% filter((is.na(mean_weight) &amp; (proportion_species &gt; 0.01))) -&gt; ptt_data_lhc_verify stopifnot(nrow(ptt_data_lhc_verify) == 0) rm(ptt_data_lhc_verify) With that out of the way we can finally remove the remaining empty rows and save the PTT and waterbird counts in their final form. ptt_data_lhc %&gt;% drop_na() -&gt; ptt_data wb_data_lhc %&gt;% drop_na() -&gt; wb_data And we save the data for further use. saveRDS(ptt_data, file = &quot;data/processed/sovon/ptt.RDS&quot;) saveRDS(wb_data, file = &quot;data/processed/sovon/wb.RDS&quot;) References "],
["06.Applying-annotations-to-all-PPIs.html", "6 Apply processing to all PPIs 6.1 Setting-up the environment 6.2 Load the reference PPIs 6.3 Copy annotations from reference PPIs to other PPIs", " 6 Apply processing to all PPIs We have so far explained the processing ‘pipeline’ for the PPIs for Herwijnen and Den Helder radars, but have only applied this to a single moment in time, a single volume scan. Now we will apply the processing to all other available PPIs by simply copying over the annotations. Pre-processed the radar data, by removing clutter and applying the range-bias correction (Kranstauber et al. 2020). Annotated the PPIs with land use classes, distance to urban areas and (human) population density. Annotated the PPIs with corresponding count locations for the Sovon data. Connected the Sovon count data with life-history characteristics for the species contained within. 6.1 Setting-up the environment library(dplyr) library(tidyr) library(kableExtra) 6.2 Load the reference PPIs Two PPIs have been processed all the way and those will be our ‘reference’ PPIs from which we copy the data over to the other PPIs which have not had the same treatment. ppi_hrw &lt;- readRDS(&quot;data/processed/corrected-ppis-lu-sovon/corrected_ppi_hrw_lu_sovon.RDS&quot;) ppi_dhl &lt;- readRDS(&quot;data/processed/corrected-ppis-lu-sovon/corrected_ppi_dhl_lu_sovon.RDS&quot;) 6.3 Copy annotations from reference PPIs to other PPIs We select the variables related to land use, distance to urbanized areas and population density, waterbird counts and PTT counts and add these to the PPIs that contain just the variables resulting from the range-bias correction (Kranstauber et al. 2020). While we are at it, we will also create dataframes containing all the information within the PPIs, to use for later modelling exercises. hrw &lt;- ppi_hrw$data@data %&gt;% dplyr::select(landuse, landuse_class, type, dist_urban, pop, wb_area_id, wb_area_nr, wb_area_ha, ptt_route) dhl &lt;- ppi_dhl$data@data %&gt;% dplyr::select(landuse, landuse_class, type, dist_urban, pop, wb_area_id, wb_area_nr, wb_area_ha, ptt_route) hrw_all &lt;- ppi_hrw$data@data %&gt;% filter(row_number() == 0) dhl_all &lt;- ppi_dhl$data@data %&gt;% filter(row_number() == 0) hrw_ppis &lt;- Sys.glob(file.path(&quot;data/processed/corrected-ppis&quot;, &quot;*NL62*&quot;)) dhl_ppis &lt;- Sys.glob(file.path(&quot;data/processed/corrected-ppis&quot;, &quot;*NL61*&quot;)) for (ppi_path in hrw_ppis) { ppi &lt;- readRDS(ppi_path) ppi$data@data &lt;- bind_cols(ppi$data@data, hrw) saveRDS(ppi, file = paste(&quot;data/processed/final-ppis/&quot;, basename(ppi_path), sep = &quot;&quot;)) ppi$data@data %&gt;% mutate(datetime = as.POSIXct(ppi$datetime), pixel = row_number()) %&gt;% bind_rows(hrw_all) -&gt; hrw_all } for (ppi_path in dhl_ppis) { ppi &lt;- readRDS(ppi_path) ppi$data@data &lt;- bind_cols(ppi$data@data, dhl) saveRDS(ppi, file = paste(&quot;data/processed/final-ppis/&quot;, basename(ppi_path), sep = &quot;&quot;)) ppi$data@data %&gt;% mutate(datetime = as.POSIXct(ppi$datetime), pixel = row_number()) %&gt;% bind_rows(dhl_all) -&gt; dhl_all } dhl_all$datetime &lt;- as.POSIXct(dhl_all$datetime) saveRDS(hrw_all, file = &quot;data/processed/hrw.RDS&quot;) saveRDS(dhl_all, file = &quot;data/processed/dhl.RDS&quot;) data/processed/hrw.RDS and data/processed/dhl.RDS now contain 13320000 and 13320000 PPI rows respectively. Below a few rows of the Herwijnen data for example (with rows containing NAs removed): hrw_all %&gt;% drop_na() %&gt;% arrange(datetime) %&gt;% head(15) %&gt;% kable(format = &quot;html&quot;, col.names = colnames(hrw_all)) %&gt;% kable_styling() %&gt;% scroll_box(width = &quot;100%&quot;, height = &quot;600px&quot;) VIR VID R overlap eta_sum eta_sum_expected dist_radar landuse landuse_class type dist_urban pop wb_area_id wb_area_nr wb_area_ha ptt_route datetime pixel 0 0 0 0.5051012 0 26.74843 159424.0 512 Water bodies rural 1802.7756 2185 632 FR3150 613.487 310 2017-12-31 22:00:04 409 0 0 0 0.5045146 0 26.71384 159594.0 512 Water bodies rural 1581.1388 2795 632 FR3150 613.487 310 2017-12-31 22:00:04 410 0 0 0 0.5045146 0 26.55445 159765.5 512 Water bodies rural 1500.0000 3105 641 FR3340 1447.750 310 2017-12-31 22:00:04 411 0 0 0 0.5039303 0 26.39407 160112.5 231 Pastures rural 500.0000 2990 641 FR3340 1447.750 375 2017-12-31 22:00:04 413 0 0 0 0.5039303 0 26.36003 160288.0 141 Green urban areas urban 0.0000 3040 641 FR3340 1447.750 375 2017-12-31 22:00:04 414 0 0 0 0.5021911 0 25.82529 161369.9 512 Water bodies rural 1581.1388 2450 695 FR4231 198.332 375 2017-12-31 22:00:04 420 0 0 0 0.5021911 0 25.79011 161554.9 512 Water bodies rural 1581.1388 1875 695 FR4231 198.332 375 2017-12-31 22:00:04 421 0 0 0 0.5016159 0 25.63913 161741.3 512 Water bodies rural 1118.0340 1455 695 FR4231 198.332 375 2017-12-31 22:00:04 422 0 0 0 0.5016159 0 25.60439 161929.0 231 Pastures rural 707.1068 1380 695 FR4231 198.332 375 2017-12-31 22:00:04 423 0 0 0 0.4890027 0 21.87696 171432.2 231 Pastures rural 500.0000 14215 217 DR1113 218.944 111 2017-12-31 22:00:04 467 0 0 0 0.4890027 0 21.76133 171674.8 231 Pastures rural 1000.0000 14245 217 DR1113 218.944 111 2017-12-31 22:00:04 468 0 0 0 0.4884807 0 21.71003 171918.6 231 Pastures rural 1414.2136 13950 217 DR1113 218.944 111 2017-12-31 22:00:04 469 0 0 0 0.4884807 0 21.59579 172163.4 231 Pastures rural 1581.1388 10645 219 DR1130 1451.280 111 2017-12-31 22:00:04 470 0 0 0 0.4879608 0 21.56972 172409.4 231 Pastures rural 1802.7756 6955 219 DR1130 1451.280 111 2017-12-31 22:00:04 471 0 0 0 0.4874431 0 21.45671 172656.5 512 Water bodies rural 2121.3203 4350 219 DR1130 1451.280 111 2017-12-31 22:00:04 472 References "],
["07.Explore-fireworks-disturbance.html", "7 Exploring fireworks disturbance 7.1 Setting-up the environment 7.2 Calculating bird parameters 7.3 Connecting Sovon counts with the PPIs 7.4 Correcting for dispersion", " 7 Exploring fireworks disturbance We have so far: Pre-processed the radar data, by removing clutter and applying the range-bias correction (Kranstauber et al. 2020). Annotated the PPIs with land use classes, distance to urban areas and (human) population density. Annotated the PPIs with corresponding count locations for the Sovon data. Connected the Sovon count data with life-history characteristics for the species contained within. With the annotated PPIs and the processed Sovon counts, we can start to explore the relation between fireworks disturbance and the birds measured aloft during NYE 2017-2018. The following parameters we assume are important predictors for measured bird densities aloft: The number of birds on the ground. The average mass of the birds on the ground. The take-off habitat of these birds The population density in the vicinity of birds, corrected for the distance to urban areas. 7.1 Setting-up the environment Load the required packages. library(mgcv) ## Loading required package: nlme ## ## Attaching package: &#39;nlme&#39; ## The following object is masked from &#39;package:raster&#39;: ## ## getData ## The following object is masked from &#39;package:dplyr&#39;: ## ## collapse ## This is mgcv 1.8-31. For overview type &#39;help(&quot;mgcv-package&quot;)&#39;. library(ggplot2) library(dplyr) library(tidyr) library(ggdark) library(bioRad) library(raster) library(dismo) library(gbm) ## Loaded gbm 2.1.5 And the files we have generated so far. ppi_hrw &lt;- readRDS(&quot;data/processed/corrected-ppis-lu-sovon/corrected_ppi_hrw_lu_sovon.RDS&quot;) ppi_dhl &lt;- readRDS(&quot;data/processed/corrected-ppis-lu-sovon/corrected_ppi_dhl_lu_sovon.RDS&quot;) ptt_raw &lt;- readRDS(&quot;data/processed/sovon/ptt.RDS&quot;) wb_raw &lt;- readRDS(&quot;data/processed/sovon/wb.RDS&quot;) 7.2 Calculating bird parameters We need to calculate the number of birds on the ground and average mass of these birds wb_raw %&gt;% mutate(area_nr = as.character(area_nr)) %&gt;% filter(year == 2018) %&gt;% group_by(area_nr) %&gt;% summarise(nr_birds = sum(number), avg_mass = weighted.mean(mean_weight, number)) %&gt;% ungroup() %&gt;% group_by(area_nr) %&gt;% summarise(nr_birds = mean(nr_birds), avg_mass = mean(avg_mass)) -&gt; wb ptt_raw %&gt;% filter(year == 2017) %&gt;% group_by(route) %&gt;% summarise(nr_birds = sum(number), avg_mass = weighted.mean(mean_weight, number)) %&gt;% ungroup() %&gt;% group_by(route) %&gt;% summarise(nr_birds = mean(nr_birds), avg_mass = mean(avg_mass)) -&gt; ptt Ideally, both the wb and ptt datasets cover somewhat different species compositions. We can easily see this if we visualise the distributions of mean_weight for these datasets. bind_rows(dplyr::select(wb, nr_birds, avg_mass), dplyr::select(ptt, nr_birds, avg_mass), .id = &quot;source&quot;) %&gt;% mutate(source = case_when( source == 1 ~ &quot;WB&quot;, source == 2 ~ &quot;PTT&quot; )) %&gt;% ggplot(aes(x = avg_mass)) + geom_density(aes(group = source, color = source)) + labs(title = &quot;Distribution of average mass in PTT and Waterbird counts&quot;) ## Warning: Removed 3 rows containing non-finite values (stat_density). And indeed, the distributions of avg_mass for PTT counts is shifted considerably to lower average weights. 7.3 Connecting Sovon counts with the PPIs Now that we have calculated the necessary ‘bird parameters’, we can attach these to the PPIs using a few simple left_joins. Subsequently, we will recalculate the avg_mass as the mean of average masses in the PTT and waterbird counts, and nr_birds by adding the numbers of birds in the PTT and waterbird counts together. The former is probably not particularly useful, so probably best to throw out at some point. ppi_hrw$data@data %&gt;% left_join(dplyr::select(wb, area_nr, nr_birds, avg_mass), by = c(&quot;wb_area_nr&quot; = &quot;area_nr&quot;)) %&gt;% rename(wb_nr_birds = nr_birds, wb_avg_mass = avg_mass) %&gt;% group_by(wb_area_nr) %&gt;% mutate(wb_nr_birds = wb_nr_birds / n()) %&gt;% ungroup() %&gt;% left_join(dplyr::select(ptt, route, nr_birds, avg_mass), by = c(&quot;ptt_route&quot; = &quot;route&quot;)) %&gt;% rename(ptt_nr_birds = nr_birds, ptt_avg_mass = avg_mass) %&gt;% group_by(ptt_route) %&gt;% mutate(ptt_nr_birds = ptt_nr_birds / n()) %&gt;% ungroup() %&gt;% mutate(nr_birds = wb_nr_birds + ptt_nr_birds, avg_mass = mean(c(wb_avg_mass, ptt_avg_mass), na.rm = TRUE)) -&gt; ppi_hrw$data@data ## Warning: Column `wb_area_nr`/`area_nr` joining factor and character vector, coercing into character vector ppi_dhl$data@data %&gt;% left_join(dplyr::select(wb, area_nr, nr_birds, avg_mass), by = c(&quot;wb_area_nr&quot; = &quot;area_nr&quot;)) %&gt;% rename(wb_nr_birds = nr_birds, wb_avg_mass = avg_mass) %&gt;% group_by(wb_area_nr) %&gt;% mutate(wb_nr_birds = wb_nr_birds / n()) %&gt;% ungroup() %&gt;% left_join(dplyr::select(ptt, route, nr_birds, avg_mass), by = c(&quot;ptt_route&quot; = &quot;route&quot;)) %&gt;% rename(ptt_nr_birds = nr_birds, ptt_avg_mass = avg_mass) %&gt;% group_by(ptt_route) %&gt;% mutate(ptt_nr_birds = ptt_nr_birds / n()) %&gt;% ungroup() %&gt;% mutate(nr_birds = wb_nr_birds + ptt_nr_birds, avg_mass = mean(c(wb_avg_mass, ptt_avg_mass), na.rm = TRUE)) -&gt; ppi_dhl$data@data ## Warning: Column `wb_area_nr`/`area_nr` joining factor and character vector, coercing into character vector 7.4 Correcting for dispersion As birds can cross substantial distances within 5 minutes (the period a single scan takes), we somehow have to take this into account during the modelling. A simple approach is to ‘smooth’ out the numbers of birds in space, by averaging the bird numbers within a given window around a focal cell. We will create a simple function to do that smooth_ppi &lt;- function(ppi, var, gridsize = c(3, 3)) { weights &lt;- matrix(1, nrow = gridsize[1], ncol = gridsize[2]) smooth_raster &lt;- raster(ppi$data[var]) smooth_nonan &lt;- smooth_raster smooth_nonan[is.na(smooth_nonan)] &lt;- 0 smooth_raster &lt;- focal(smooth_nonan, w = weights, fun = mean, pad = TRUE, padValue = 0) return(unlist(as.data.frame(as(smooth_raster, &quot;Raster&quot;)))) } ppi_hrw$data$birds_smooth_9 &lt;- smooth_ppi(ppi_hrw, &quot;wb_nr_birds&quot;) ppi_hrw$data$birds_smooth_15 &lt;- smooth_ppi(ppi_hrw, &quot;wb_nr_birds&quot;, gridsize = c(5, 5)) ppi_dhl$data$birds_smooth_9 &lt;- smooth_ppi(ppi_dhl, &quot;wb_nr_birds&quot;) ppi_dhl$data$birds_smooth_15 &lt;- smooth_ppi(ppi_dhl, &quot;wb_nr_birds&quot;, gridsize = c(5, 5)) plot(ppi_hrw, param = &quot;ptt_nr_birds&quot;, zlim = c(min(ppi_hrw$data@data$ptt_nr_birds, na.rm = TRUE), quantile(ppi_hrw$data@data$ptt_nr_birds, 0.95, na.rm = TRUE))) plot(ppi_hrw, param = &quot;wb_nr_birds&quot;, zlim = c(min(ppi_hrw$data@data$wb_nr_birds, na.rm = TRUE), quantile(ppi_hrw$data@data$wb_nr_birds, 0.95, na.rm = TRUE))) plot(ppi_hrw, param = &quot;VIR&quot;, zlim = c(min(ppi_hrw$data$VIR), quantile(ppi_hrw$data$VIR, 0.99))) ppi_hrw_mass &lt;- ppi_hrw$data@data ppi_hrw_mass %&gt;% filter(VIR &gt; 50 &amp; wb_nr_birds &gt; 0 &amp; type == &quot;rural&quot; &amp; VIR &lt; quantile(ppi_hrw_mass$VIR, 0.99, na.rm = TRUE)) %&gt;% # filter(birds_smooth_9 &lt; quantile(ppi_hrw_mass$birds_smooth_9, 0.99, na.rm = TRUE)) %&gt;% mutate(vid_new = VIR / wb_avg_mass, birds = wb_nr_birds * wb_avg_mass, # pop_eff = pop / (dist_urban / 1000), pop_eff = pop * (1 / dist_urban), birds_smooth_log = log(birds_smooth_9)) %&gt;% group_by(pop_eff) %&gt;% mutate(avg_mass_pop = mean(wb_avg_mass), avg_birds_pop = mean(birds_smooth_9), sum_birds_pop = sum(birds_smooth_9), sum_vid_pop = sum(vid_new), birds = mean(c(birds_smooth_9, wb_nr_birds), drop.na = TRUE)) %&gt;% ungroup() %&gt;% mutate(sum_birds_pop = scale(sum_birds_pop, scale = TRUE, center = TRUE) * 10 + 10, sum_vid_pop = scale(sum_vid_pop, scale = TRUE, center = TRUE) * 10 + 10) %&gt;% group_by(vid_new) %&gt;% mutate(avg_mass_pop_vid = mean(wb_avg_mass), avg_birds_pop_vid = mean(birds_smooth_9)) %&gt;% ungroup() %&gt;% mutate(landuse_overall = case_when( (landuse &gt;= 100 &amp; landuse &lt; 200) ~ &quot;Urban&quot;, (landuse &gt;= 200 &amp; landuse &lt; 300) ~ &quot;Agricultural areas&quot;, (landuse &gt;= 300 &amp; landuse &lt; 500) ~ &quot;Natural areas&quot;, (landuse &gt;= 500 &amp; landuse &lt; 999) ~ &quot;Water bodies&quot; )) %&gt;% dplyr::select(VIR, wb_nr_birds, birds, birds_smooth_9, birds_smooth_15, pop, dist_urban, pop_eff, landuse_overall) %&gt;% drop_na() -&gt; ppi_mdl # drop_na() -&gt; ppi_mdl # ppi_hrw$data@data %&gt;% # filter(VIR &gt; 0 &amp; VIR &lt; quantile(ppi_hrw$data@data$VIR, 0.99, na.rm = TRUE)) %&gt;% # filter(birds_smooth_9 &gt; 0 &amp; birds_smooth_9 &lt; quantile(ppi_hrw$data@data$VIR, 0.99, na.rm = TRUE)) %&gt;% # filter(type == &quot;rural&quot;) %&gt;% # mutate(landuse_overall = case_when( # (landuse &gt;= 100 &amp; landuse &lt; 200) ~ &quot;Urban&quot;, # (landuse &gt;= 200 &amp; landuse &lt; 300) ~ &quot;Agriculture&quot;, # (landuse &gt;= 300 &amp; landuse &lt; 500) ~ &quot;Nature&quot;, # (landuse &gt;= 500 &amp; landuse &lt; 999) ~ &quot;Water bodies&quot; # )) %&gt;% # drop_na() -&gt; ppi_mdl # m1 &lt;- glm(VIR ~ wb_nr_birds + pop + dist_urban + landuse_overall, data = ppi_mdl, family = Gamma(link = &quot;log&quot;)) m1 &lt;- gam(VIR ~ s(birds) + s(pop) + s(dist_urban, k = 20) + landuse_overall, data = ppi_mdl, method = &quot;REML&quot;, family = Gamma(link = &quot;log&quot;)) # gam(vid_new ~ s(birds_smooth_9, k = 20) + s(pop) + s(dist_urban) + s(pop_eff) + landuse_overall, data = ppi_mdl, method = &quot;REML&quot;, family = Gamma(link = &quot;log&quot;)) -&gt; m1 summary(m1) plot(m1) gam.check(m1) # with(summary(m1), 1 - deviance/null.deviance) ## ## Family: Gamma ## Link function: log ## ## Formula: ## VIR ~ s(birds) + s(pop) + s(dist_urban, k = 20) + landuse_overall ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 7.17947 0.01298 553.087 &lt; 2e-16 *** ## landuse_overallNatural areas -0.07096 0.04754 -1.493 0.135578 ## landuse_overallWater bodies -0.09325 0.02776 -3.359 0.000785 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(birds) 7.982 8.724 49.07 &lt;2e-16 *** ## s(pop) 8.421 8.906 21.68 &lt;2e-16 *** ## s(dist_urban) 6.655 8.168 25.16 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.0658 Deviance explained = 6.95% ## -REML = 1.0116e+05 Scale est. = 1.4401 n = 12417 ## ## Method: REML Optimizer: outer newton ## full convergence after 6 iterations. ## Gradient range [-0.07029831,0.04092964] ## (score 101163.1 &amp; scale 1.440129). ## Hessian positive definite, eigenvalue range [1.898124,8280.759]. ## Model rank = 40 / 40 ## ## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may ## indicate that k is too low, especially if edf is close to k&#39;. ## ## k&#39; edf k-index p-value ## s(birds) 9.00 7.98 0.78 &lt;2e-16 *** ## s(pop) 9.00 8.42 0.85 0.045 * ## s(dist_urban) 19.00 6.66 0.90 0.970 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # ppi_mdl %&gt;% # filter(VIR &gt; 0) %&gt;% # mutate(VIR_log10 = log10(VIR), # landuse_overall = case_when( # landuse_overall == &quot;Agricultural areas&quot; ~ 1, # landuse_overall == &quot;Water bodies&quot; ~ 2, # landuse_overall == &quot;Natural areas&quot; ~ 3 # ))-&gt; ppi_bt # # ppi_bt$landuse_overall &lt;- as.numeric(ppi_bt$landuse_overall) # # ppi_bt &lt;- as.data.frame(ppi_bt) # # response &lt;- &quot;VIR_log10&quot; # predictors &lt;- c(&quot;wb_nr_birds&quot;, &quot;birds&quot;, &quot;birds_smooth_9&quot;, &quot;pop&quot;, &quot;dist_urban&quot;, &quot;pop_eff&quot;, &quot;landuse_overall&quot;) # # bt &lt;- gbm.step(data = ppi_bt, gbm.x = 2:8, gbm.y = 10, tree.complexity = 2, bag.fraction = 0.5, family = &quot;gaussian&quot;) # a &lt;- predict(bt5, ppi_bt, n.trees = 10000, type = &quot;response&quot;) # ppi_bt$preds &lt;- a # # ggplot(ppi_bt, aes(x = preds, y = VIR_log10)) + # geom_pointdensity() + # geom_abline() References "],
["A1.Generating-VPs-for-Den-Helder-radar.html", "8 Generating vertical profiles for Den Helder radar", " 8 Generating vertical profiles for Den Helder radar The Den Helder radar is situated very close to the coast, so take-off densities derived from the calculate_vp() function in bioRad (Dokter et al. 2019) are likely underestimated as large swaths of sea (both North and Wadden Sea) are contained within the volume. To correct for this, we will select a section, defined by minimum and maximum azimuths, to generate the vertical profiles for. We load the DBZH from the polar volume containing the peak moment of take-off for the Den Helder radar, which occurs at 23:05 UTC. library(bioRad) pvol_path &lt;- &quot;data/raw/pvol/fireworks-2017-2018/RAD_NL61_VOL_NA_201712312305_ODIM.h5&quot; pvol &lt;- read_pvolfile(pvol_path, param = &quot;DBZH&quot;) To illustrate the problem, let’s plot the lowest scan of the pvol we have loaded: scan &lt;- get_scan(pvol, 0.3) plot(scan) As can be seen, there is a large swath of sea clutter, roughly between azimuths 200 and 325. The Wadden Sea can be seen from azimuths 45 until roughly 90. The area in between is where the majority of birds take off: the mainland of North Holland. We can visualise what a focus on this area would cover by plotting a PPI where all values between azimuths 90 and 200 have been set to a very high value. See below: scan_section &lt;- scan scan_section$params$DBZH[, 90:200] &lt;- 100 ppi &lt;- project_as_ppi(scan, grid_size = 100, range_max = 35000) ppi_section &lt;- project_as_ppi(scan_section, grid_size = 100, range_max = 35000) par(pty = &quot;s&quot;, mfrow = c(1, 2)) plot(ppi) plot(ppi_section) Now with that in mind we can calculate the vps for the entire area and compare that with one that is calculated just from the section above (azimuths between 90 and 200). vp_all_azimuths = calculate_vp(pvol_path, verbose = FALSE) vp_land_based_azimuths = calculate_vp(pvol_path, azim_min = 90, azim_max = 200, verbose = FALSE) And plot the corresponding VPs: plot(vp_all_azimuths, main = &quot;VP calculated from the entire Den Helder radar domain&quot;) plot(vp_land_based_azimuths, main = &quot;VP calculated from the main land area covered by Den Helder radar&quot;) We can see there is a substantial difference in density derived from the VPs when focussing on the main land of North Holland vs. when we look at the entire radar domain and include large swaths of the North and Wadden Sea. References "],
["References.html", "9 References", " 9 References "]
]
